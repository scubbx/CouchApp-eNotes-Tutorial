% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}


\title{CouchApp Tutorial Documentation}
\date{January 20, 2012}
\release{0.2}
\author{Markus Mayr}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


You will learn how to build a simple note taking application which is stored in a CouchDB. The complete logic, design and data of the application will be contained within a single database. This gives the benefit of CouchDBs replication feature and other database specific properties to your application for free.
The application will run in any recent webbrowser that is able to interpret JavaScript - this means that it will work with mobile devices as well as with desktop computers.

Basic knowledge of CouchDB, JavaScript and HTML is assumed. We will combine these and other techniques to produce a simple example.

In this tutorial, system specific commands are based on \emph{Linux} / \emph{Bash}.

Please be advised that you should follow this tutorial step by step if you want to have your CouchApp working right. There are a lot of cross references inside the code and it is easy to lose track. However, if you are confident enough to do otherwise, please feel free to do so. ;-)

If you are interested in expanding this tutorial or correct an error, take a look at it's Github page: \href{https://github.com/scubbx/CouchApp-eNotes-Tutorial}{https://github.com/scubbx/CouchApp-eNotes-Tutorial}

The code is open source.


\chapter{Needed Software}
\label{1-UsedSoftware:needed-software}\label{1-UsedSoftware::doc}\label{1-UsedSoftware:welcome-to-the-couchapp-tutorial}
Here will be explained what software to use and why. This page gives only a small overview of the capabilities of software used for CouchApps. For a more detailed explanation please refer to tutorials written specifically for each individual software.

For our application, we need three types of information:
\begin{itemize}
\item {} 
Layout

\item {} 
Data

\item {} 
Program Logic

\end{itemize}

For this we will only use software and software-principles that are also used in current state of the art web development projects:
\begin{itemize}
\item {} 
HTML \& CSS

\item {} 
JavaScript (including JSON, jQuery and evently)

\item {} 
moustache

\item {} 
CouchDB

\end{itemize}

The responsibilities of different pieces of software can be seen like this:

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{
Part of Application
} & \textbf{
Techniques used
}\\
\hline

Layout
 & 
HTML, CSS, jQuery, mustache
\\

Data
 & 
JSON, evently
\\

Program Logic
 & 
JavaScript, jQuery, evently
\\
\hline
\end{tabulary}



\section{HTML \& CSS}
\label{1-UsedSoftware:html-css}
Everyone involved in web-programming knows HTML at least to some extent. In the CouchApp context, this \emph{HyperTextMarkupLanguage} is used to describe the user interface and design of the application.
It can easily be stored inside the CouchDB as an \textbf{attachment} and accessed by a single URL.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\textless{}html}\PYG{n+nt}{\textgreater{}}
        \PYG{n+nt}{\textless{}head}\PYG{n+nt}{\textgreater{}}

        \PYG{n+nt}{\textless{}/head\textgreater{}}
        \PYG{n+nt}{\textless{}body}\PYG{n+nt}{\textgreater{}}
                \PYG{n+nt}{\textless{}a}\PYG{n+nt}{\textgreater{}}Lore ipsum\PYG{n+nt}{\textless{}/a\textgreater{}}
        \PYG{n+nt}{\textless{}/body\textgreater{}}
\PYG{n+nt}{\textless{}/html\textgreater{}}
\end{Verbatim}

HTML holds the \textbf{layout} of the CouchApp.


\section{JavaScript}
\label{1-UsedSoftware:javascript}
Since HTML does not allow any program
logic or multidirectional interaction to be implemented by itself, JavaScript is used to accieve this goal. This is only logical because it is natively supported by various browsers on different systems.
JavaScript code can be stored inside the CouchDB as \textbf{part of CouchDB - documents} and accessed via the REST interface.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{n+nx}{testFunction}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{alert}\PYG{p}{(}\PYG{l+s+s2}{"This is just a test."}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

JavaScript is responsible for \textbf{storing the logic} of the program.


\subsection{JSON}
\label{1-UsedSoftware:json}
There exists a standard notation for describing data in JavaScript. It is called \emph{JavaScriptObjectNotation}.
Actually, this is just a data container (variable) in pure JavaScript.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
        \PYG{l+s+s2}{"Entry1"} \PYG{o}{:} \PYG{l+s+s2}{"Value1"}\PYG{p}{,}
        \PYG{l+s+s2}{"Entry2"} \PYG{o}{:} \PYG{l+s+s2}{"Value2"}\PYG{p}{,}
        \PYG{l+s+s2}{"Entry3"} \PYG{o}{:} \PYG{l+s+s2}{"2649"}\PYG{p}{,}
        \PYG{l+s+s2}{"Entry4"} \PYG{o}{:} \PYG{k+kc}{true}\PYG{p}{,}
        \PYG{l+s+s2}{"Entry5"} \PYG{o}{:} \PYG{p}{[} \PYG{l+s+s2}{"blue"}\PYG{p}{,} \PYG{l+s+s2}{"green"}\PYG{p}{,} \PYG{l+s+s2}{"red"} \PYG{p}{]}\PYG{p}{,}
        \PYG{l+s+s2}{"Entry6"} \PYG{o}{:} \PYG{k+kc}{null}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

JSON entries can also be nested:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
        \PYG{l+s+s2}{"Entry1"} \PYG{o}{:} \PYG{l+s+s2}{"Value1"}
        \PYG{l+s+s2}{"Entry2"} \PYG{o}{:} \PYG{l+s+s2}{"Value2"}\PYG{p}{,}
        \PYG{l+s+s2}{"Entry3"} \PYG{o}{:} \PYG{p}{\PYGZob{}}
                \PYG{l+s+s2}{"SubEntry1"} \PYG{o}{:} \PYG{l+s+s2}{"Value3"}\PYG{p}{,}
                \PYG{l+s+s2}{"SubEntry2"} \PYG{o}{:} \PYG{l+m+mi}{342}
        \PYG{p}{\PYGZcb{}}\PYG{p}{,}
        \PYG{l+s+s2}{"Entry4"} \PYG{o}{:} \PYG{l+s+s2}{"Value4"}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

JSON is used whenever information is processed. This covers \textbf{data} or \textbf{program logic}.


\subsection{jQuery (mobile)}
\label{1-UsedSoftware:jquery-mobile}
jQuery is a JavaScript library that simplifies access to the DOM structure of HTML documents. It also offeres standardised ways to access functions that differ with different browsers and offeres additional effects for the design of HTML pages.

jQuery syntax example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"a"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{click}\PYG{p}{(}
        \PYG{k+kd}{function}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n+nx}{alert}\PYG{p}{(}\PYG{l+s+s2}{"This is just a test."}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

This code means that whenever you click on an element of the HTML page that is formatted with an \code{\textless{}a\textgreater{}} tag (basically every normal text or hyperlink) the function \code{function()\{ alert("This is just a test."); \}} is executed.
The useage of jQuery with CouchApp is mainly supported by its standardising and graphical powers. It is mainly responsible for the \textbf{layout}.
We will use a specialized mobile - version of jQuery called \emph{jQuery mobile}.


\subsection{jQuery UI CSS}
\label{1-UsedSoftware:jquery-ui-css}
The jQuery UI CSS is a simple css template which facilitates the creation of custom control elements in a html page.
There is also a mobile - version available which will be used in our context.

\href{http://jqueryui.com/}{http://jqueryui.com/}


\subsection{evently}
\label{1-UsedSoftware:evently}
Evently is a wrapper for jQuery functions. It facilitates the manipulation and addition of event handlers to DOM elements. It also has a mustache parser and allows to apply them via ajax requests.

Basic Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"exampleDOMobject"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{evently}\PYG{p}{(} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{click} \PYG{o}{:} \PYG{k+kd}{function}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n+nx}{alert}\PYG{p}{(}\PYG{l+s+s2}{"This is a Test."}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}\PYG{p}{,}
        \PYG{n+nx}{mouseenter} \PYG{o}{:} \PYG{k+kd}{function}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n+nx}{alert}\PYG{p}{(}\PYG{l+s+s2}{"This is ANOTHER Test."}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

Here we can see a structure similar to a JSON object that defines different functions for different events.
The purpose of evently with CouchApps lies within the \textbf{program logic} and \textbf{data} handling.


\section{mustache}
\label{1-UsedSoftware:mustache}
Mustache is another JavaScript library that lets us insert placeholders in HTML (or any other text). These are specified by \code{\{\{} at the beginning of the placeholder and \code{\}\}} at the end.
Take this example for a template text with placeholders like \code{\{\{city\}\}} or \code{\{\{temperature\_c\}\}}:

\begin{Verbatim}[commandchars=\\\{\}]
You are at \PYGZob{}\PYGZob{}city\PYGZcb{}\PYGZcb{}.
The temperature is \PYGZob{}\PYGZob{}temperature\PYGZus{}c\PYGZcb{}\PYGZcb{} degrees C!
\PYGZob{}\PYGZob{}\PYGZsh{}in\PYGZus{}f\PYGZcb{}\PYGZcb{}
        In Fahrenheit this would be \PYGZob{}\PYGZob{}temperature\PYGZus{}f\PYGZcb{}\PYGZcb{}
\PYGZob{}\PYGZob{}/in\PYGZus{}f\PYGZcb{}\PYGZcb{}
\end{Verbatim}

The reason this tool is used is that it takes JSON objects as input and inserts its values into placeholders of corresponding name.

The lines between \code{\{\{\#in\_f\}\}} and \code{\{\{/in\_f\}\}} are only rendered when the variable \code{"in\_f"} is set to \code{true}.

This is the JSON object that is fed into the mustache parser:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
        \PYG{l+s+s2}{"city"}\PYG{o}{:} \PYG{l+s+s2}{"Vienna"}\PYG{p}{,}
        \PYG{l+s+s2}{"temperature"}\PYG{o}{:} \PYG{l+m+mi}{22}\PYG{p}{,}
        \PYG{l+s+s2}{"temperature\PYGZus{}f"}\PYG{o}{:} \PYG{p}{(} \PYG{p}{(}\PYG{l+m+mi}{22} \PYG{o}{*} \PYG{l+m+mi}{9}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{5} \PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{32}\PYG{p}{,}
        \PYG{l+s+s2}{"in\PYGZus{}f"}\PYG{o}{:} \PYG{k+kc}{true}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Every \code{\{\{city\}\}} in our template HTML is replaced by the value of the \code{city} tag in the JSON object. In this case, the substitute would be \code{Vienna}.
As you can see by \code{"temperature\_f"}, you may also put simple formulas as values (like \code{( (22 * 9) / 5 ) + 32} in this case) .
The final output of the template and the JSON object would look like this:

\begin{Verbatim}[commandchars=\\\{\}]
You are at Vienna.
The temperature is 22 degrees C!
In Fahrenheit this would be 71.6
\end{Verbatim}

Mustache is perfectly suited for our needs because we will receive data our CouchApp requests from the CouchDB as JSON objects.


\section{CouchDB}
\label{1-UsedSoftware:couchdb}
CouchDB is the heart of every CouchApp. It is the storage of and interface to every bit of information. One does not need to gain knowledge of or implement a specific API since CouchDB uses simple HTTP requests to deliver data in JSON format. Attached files (like HTML or images) can be accessed by a specifically formatted URL.

\begin{Verbatim}[commandchars=\\\{\}]
http://127.0.0.1:5984/
\end{Verbatim}

This will give you a welcome message, the version of the database and possibly various other meta information in JSON format:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
        \PYG{l+s+s2}{"couchdb"} \PYG{o}{:} \PYG{l+s+s2}{"Welcome"}\PYG{p}{,}
        \PYG{l+s+s2}{"version"} \PYG{o}{:} \PYG{l+s+s2}{"1.1.0"}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

To get a list of all available databases, one would request:

\begin{Verbatim}[commandchars=\\\{\}]
http://127.0.0.1:5984/\PYGZus{}all\PYGZus{}dbs
\end{Verbatim}

To access previously attached files, only a specific URL is necessary. It is composed of the base URL (\code{http://127.0.0.1:5984}), the database name (\code{/albums}), the ID of the database document the file is attached to (\code{/6e1295ed6c29495e54cc05947f18c8af}) and, at last, the filename itself (\code{/artwork.jpg}):

\begin{Verbatim}[commandchars=\\\{\}]
http://127.0.0.1:5984/albums/6e1295ed6c29495e54cc05947f18c8af/artwork.jpg
\end{Verbatim}

CouchDB will not be explained in detail. For more information please refer to the excellent free online book \href{http://guide.couchdb.org/index.html}{``The Definitive Guide to CouchDB''}.


\section{CouchApp}
\label{1-UsedSoftware:couchapp}
CouchApp itself is not only the name for the concept of storing an application inside an CouchApp, but also an application that helps us create CouchApps.

\href{http://couchapp.org/page/what-is-couchapp}{http://couchapp.org/page/what-is-couchapp}


\chapter{First Steps with CouchAPP}
\label{2-Start:first-steps-with-couchapp}\label{2-Start::doc}
Here you will learn some details of the folder structure and the meaning of specific files inside your CouchApp directory. If you feel familiar enough with this, you may already proceed to the next topic, but bear in mind to at least generate an empty CouchApp before proceeding any further.


\section{Start with CouchApp}
\label{2-Start:start-with-couchapp}

\subsection{Create working directories and files}
\label{2-Start:create-working-directories-and-files}
To set up a CouchApp, we start the actual CouchApp program to generate a directory structure where all of our code will be saved to at corresponding places. After the upload of our CouchApp into a CouchDB, most of these files and folders will form the design document of our application.

Move to any directory you like. Don't worry, a sub directory for our project will be created in our next step automatically. For this example I will go to my \emph{./Documents} folder and start the \code{couchapp} program with it's appropriate arguments. You may use whatever directory you like.:

\begin{Verbatim}[commandchars=@\[\]]
@$ cd Documents

/Documents@$ couchapp generate enotes
\end{Verbatim}

The \code{couchapp} command is launched with the \code{generate} option. This will command couchapp to generate a new CouchApp project and trigger the creation of all necessary directories. The \code{enotes} part describes the name of our application. Acutally, you may change it to your liking, but for reasons of compatibility to this tutorial I recommend you to stick with this proposition.

If we take a look at the newly generated file tree we see the following directories and files (there are also hidden files!):

\begin{Verbatim}[commandchars=@\[\]]
enotes@$ ls

./@_attachments
./lists
./shows
./updates
./vendor
./views
.chouchappignore
.couchapprc
couchapp.json
@_id
language
README.md
\end{Verbatim}

We will go through each of this entries and explain what they are. If necessary we will also fill in certain values.


\subsection{.couchappignore}
\label{2-Start:couchappignore}
This file defines files or folders that may be located inside our tree but should not be uploaded to the CouchDB. Regular Expressions (RegEx) are used to define these.
The \code{.couchappignore} default looks like this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}
\PYG{c+c1}{// filenames matching these regexps will not be pushed to the database}
\PYG{c+c1}{// uncomment to activate; separate entries with ","}
\PYG{c+c1}{// ".*\PYGZti{}\PYGZdl{}"}
\PYG{c+c1}{// ".*\PYGZbs{}\PYGZbs{}.swp\PYGZdl{}"}
\PYG{c+c1}{// ".*\PYGZbs{}\PYGZbs{}.bak\PYGZdl{}"}
\PYG{p}{]}
\end{Verbatim}

As we can see, all possible pre-defined values are switched off by the leading \code{//}. If you ever produce objects that are not necessary for your CouchApp to work (like a SVN control directory), you should include a line for them here. We do not need to do this for our CouchApp tutorial.


\subsection{.couchapprc}
\label{2-Start:couchapprc}
The hidden \code{.couchapprc} file contains information of the CouchDB (or CouchDBs) our application will be integrated into in \emph{JSON} format. The file looks like this when it is initially generated:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\end{Verbatim}

We don't need to fill anything in here, but it could be very helpful when finally uploading the CouchApp to a CouchDB. It may look like this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
    \PYG{l+s+s2}{"env"} \PYG{o}{:} \PYG{p}{\PYGZob{}}
        \PYG{l+s+s2}{"testDB"} \PYG{o}{:} \PYG{p}{\PYGZob{}}
            \PYG{l+s+s2}{"db"} \PYG{o}{:} \PYG{l+s+s2}{"http://localhost:5984/test-database"}
        \PYG{p}{\PYGZcb{}}\PYG{p}{,}
        \PYG{l+s+s2}{"finalDB"} \PYG{o}{:} \PYG{p}{\PYGZob{}}
            \PYG{l+s+s2}{"db"} \PYG{o}{:} \PYG{l+s+s2}{"http://username:password@anyserver.com/final-database"}
        \PYG{p}{\PYGZcb{}}\PYG{p}{,}
        \PYG{l+s+s2}{"default"} \PYG{o}{:} \PYG{p}{\PYGZob{}}
            \PYG{l+s+s2}{"db"} \PYG{o}{:} \PYG{l+s+s2}{"http://localhost:5984/default-database"}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

In the example above (which we \emph{don't} enter in our file right now), there are three different databases specified by JSON notation in the \code{env} section. When uploading the CouchApp later on we don't have to specify the database connections but can simply use the terms \code{testDB} or \code{finalDB}. If no database is named when uplading the CouchApp, the one defined by the value \code{default} is used.

So let's enter the following code to our \code{.couchapprc} file:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
    \PYG{l+s+s2}{"env"} \PYG{o}{:} \PYG{p}{\PYGZob{}}
        \PYG{l+s+s2}{"default"} \PYG{o}{:} \PYG{p}{\PYGZob{}}
            \PYG{l+s+s2}{"db"} \PYG{o}{:} \PYG{l+s+s2}{"http://localhost:5984/enotes"}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

By this, our default database named \code{enotes} is defined to be on our local machine (\code{localhost:5894}).
There are more options that can be included in this file which we will ignore for the time being.


\subsection{couchapp.json}
\label{2-Start:couchapp-json}
This file contains basic information about our project.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
    \PYG{l+s+s2}{"name"}\PYG{o}{:} \PYG{l+s+s2}{"Basic CouchApp"}\PYG{p}{,}
    \PYG{l+s+s2}{"description"}\PYG{o}{:} \PYG{l+s+s2}{"CouchApp with changes feed and form support."}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Change it to your liking.


\subsection{\_id}
\label{2-Start:id}
Most of the files we edit will form the design document of our CouchApp. Every document in CouchApp needs an \code{\_id} field. Design documents are identified by an id with the value \code{\_design/} followed by it's name. Hereby, this is also the default value for this file:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{\PYGZus{}design}\PYG{o}{/}\PYG{n}{enotes}
\end{Verbatim}


\subsection{language}
\label{2-Start:language}
This defines the pragramming language which is used for this project. Since we will only resort to \code{javascript}, we leave the default entry as it is:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{javascript}
\end{Verbatim}


\subsection{README.md}
\label{2-Start:readme-md}
This is some information about what CouchApp is and how to access it.


\subsection{./\_attachments}
\label{2-Start:attachments}
Here, files that define the layout, interface and basic functionality of our application are stored. Files ald folders located within its directory are included as attachments to the design document. I want to draw your attention to the file \code{index.html}. It will contain our interface and is the file that is called when starting our CouchApp.


\subsection{./lists   ./shows   ./updates}
\label{2-Start:lists-shows-updates}
These folders are not used by our CouchApp.


\subsection{./vendor}
\label{2-Start:vendor}
Files stored in this directory are also attached to the CouchDB design document. Usually, libraries from sources other than our manually created ones are put here, but also functions connecting the CouchApp programming interface to other libraries are located here.


\subsection{./views}
\label{2-Start:views}
All data views that are necessary are stored in this directory. Each sub folder describes one view and contains at least a \code{map.js} file, but most of the time also a \code{reduce.js}. (the latter one is not yet present in our example)
As you might have guessed, these two files correspond to the \emph{map} and \emph{reduce} functions used by CouchDb.


\section{Upload the CouchApp}
\label{2-Start:upload-the-couchapp}
Without any further canges, we could upload this example CouchApp to our CouchDB. For this, we would use the couchapp program again.

\begin{Verbatim}[commandchars=@\[\]]
enotes@$ couchapp push enotes
\end{Verbatim}

This command uses the option \code{push} to initiate the upload to the database named \code{enotes}. Note that this database will be created automatically.

If you remember, we have defined a database connection in the \code{.couchapprc} file. So we could also just enter

\begin{Verbatim}[commandchars=@\[\]]
enotes@$ couchapp push
\end{Verbatim}


\section{Review the \_design document}
\label{2-Start:review-the-design-document}
To gain a better understanding of the principles behind CouchApp, let's take a look at the database created by our upload.
To do so, we enter the CouchDB gui via a web browser:

\begin{Verbatim}[commandchars=@\[\]]
http://localhost:5984/@_utils
\end{Verbatim}

You should see a list of all your CouchDB databases of which one should be named \emph{``enotes''}.
\begin{quote}

\includegraphics{2_firstdb.png}
\end{quote}

Klick on it and you will see all documents that are currently stored inside this database (which contains our enotes application).
\begin{quote}

\includegraphics{2_documents.jpg}
\end{quote}

Don't be surprised, there is only one document present. This is the design document. When adding content later on, it will also be stored as additional documents at this very location. Open the design document.
You should be presented with a view similar to this:
\begin{quote}

\includegraphics{2_design.png}
\end{quote}

Take a look at the \code{Field} column. Most of these entries represent files or folders from our CouchApp directory tree. The files have been converted to entries in the design document of our CouchApp.
Especially interesting is the \code{\_attachments} entry. These are attached files that can be accessed directly by their URL (but are stored inside the CouchDB). The other fields are using JSON for formatting and storing information (functions, tags, ...)


\section{Test the CouchApp}
\label{2-Start:test-the-couchapp}
To start our CouchApp, we simply have to access the CouchDB. As we know, this is done via a simple HTTP command.:

\begin{Verbatim}[commandchars=@\[\]]
http://localhost:5984/enotes/@_design/enotes/index.html
\end{Verbatim}

This is exaclty the same link as the one accessed when clicking on \code{index.html} in the \code{\_attachments} entry in our design document.
\begin{quote}

\includegraphics{2_index.jpg}
\end{quote}

Let's take a closer look at this url. It is quite clear that \code{http://localhost:5984} points to the CouchDB server on our local machine. The following \code{/enotes} describes the database where our CouchApp is stored. Appending \code{/\_design/enotes} tells the server to open the design document with the Id \emph{\_design/enotes}. The final string \code{/index.html} accesses the appended \emph{index.html} and therefore starts our CouchApp.


\chapter{Write the Interface}
\label{3-Interface:write-the-interface}\label{3-Interface::doc}
As said previously, the interface layout is defined by HTML and CSS. This HTML and CSS are stored as attachments in the design document of our application. When we want to execute our CouchApp, we simply call the HTML. We can access attachments just like normal web-pages via its URL.

So, let's just open the file \code{index.html} in the folder \code{./\_attachments} for editing.

It is already filled with code which we will remove completely. So we will be left with an empty file. Now it's time to start filling in our own code!

The following graphic gives an overview of the files we have to download and add to our CouchApp:

\includegraphics{graphviz-760f5b9834e23e898b9076f23291eb684c5f2d81.pdf}

Elements not encircled by a gray line are files and folders we will create in the next sections.


\section{HTML Structure \& \textless{}head\textgreater{}}
\label{3-Interface:html-structure-head}
First, we enter a basic HTML structure. In the \code{\textless{}head\textgreater{}} section, we will fill in \textbf{meta-information} and the page title. Additionally we enter references to \textbf{two css stylesheets} we will download afterwards:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\textless{}!DOCTYPE html\textgreater{}}
\PYG{n+nt}{\textless{}html}\PYG{n+nt}{\textgreater{}}
    \PYG{n+nt}{\textless{}head}\PYG{n+nt}{\textgreater{}}
        \PYG{n+nt}{\textless{}meta} \PYG{n+na}{charset=}\PYG{l+s}{"utf-8"} \PYG{n+nt}{/\textgreater{}}
        \PYG{n+nt}{\textless{}meta} \PYG{n+na}{name=}\PYG{l+s}{"viewport"} \PYG{n+na}{content=}\PYG{l+s}{"width=device-width,minimum-scale=1,maximum-scale=1"}\PYG{n+nt}{\textgreater{}}
        \PYG{n+nt}{\textless{}title}\PYG{n+nt}{\textgreater{}}eNotes\PYG{n+nt}{\textless{}/title\textgreater{}}

        \PYG{n+nt}{\textless{}link} \PYG{n+na}{rel=}\PYG{l+s}{"stylesheet"} \PYG{n+na}{href=}\PYG{l+s}{"style/jquery.mobile-1.0.css"} \PYG{n+na}{type=}\PYG{l+s}{"text/css"}\PYG{n+nt}{/\textgreater{}}
        \PYG{n+nt}{\textless{}link} \PYG{n+na}{rel=}\PYG{l+s}{"stylesheet"} \PYG{n+na}{href=}\PYG{l+s}{"style/jquery-ui-1.8.16.custom.css"} \PYG{n+na}{type=}\PYG{l+s}{"text/css"}\PYG{n+nt}{/\textgreater{}}
    \PYG{n+nt}{\textless{}/head\textgreater{}}
    \PYG{n+nt}{\textless{}body}\PYG{n+nt}{\textgreater{}}

    \PYG{n+nt}{\textless{}/body\textgreater{}}
\PYG{n+nt}{\textless{}/html\textgreater{}}
\end{Verbatim}

The ``meta-information'' consists of the \code{charset} used to encode the html and the definition of the \code{viewport}. The viewport variable is important for mobile browsers so that they can resize our layout accordingly.


\section{CSS}
\label{3-Interface:css}
We have to download the two css stylesheet files we just referenced to and move them to their appropriate location in our CouchApp directory tree.


\subsection{jQuery UI CSS}
\label{3-Interface:jquery-ui-css}\begin{itemize}
\item {} 
You can get the \textbf{jQuery UI CSS} at \href{http://jqueryui.com/download/jquery-ui-1.8.16.custom.zip}{http://jqueryui.com/download/jquery-ui-1.8.16.custom.zip} .

\item {} 
Open the downloaded archive and go to \code{/css/smoothness/}. Here you will see the file \code{jquery-ui-1.8.16.custom.css} and the directory \code{/image}. Extract both of them to the \code{/enotes/\_attachments/style/} folder.

\item {} 
In the archive at \code{/js/} you will find two \emph{.js} files. These need to be extracted to \code{/enotes/vendor/couchapp/\_attachments/}.

\end{itemize}


\subsection{jQuery Mobile CSS}
\label{3-Interface:jquery-mobile-css}
Download the file \href{http://code.jquery.com/mobile/1.0/jquery.mobile-1.0.css}{http://code.jquery.com/mobile/1.0/jquery.mobile-1.0.css} to \code{/enotes/\_attachments/style/}.


\section{JavaScript Library}
\label{3-Interface:javascript-library}
While we are at it, we may already download \textbf{jQuery mobile}. You can find it at \href{http://code.jquery.com/mobile/1.0/jquery.mobile-1.0.min.js}{http://code.jquery.com/mobile/1.0/jquery.mobile-1.0.min.js} .
Place it at \code{/enotes/vendor/couchapp/\_attachments/}.


\section{HTML \textless{}body\textgreater{}}
\label{3-Interface:html-body}
Now, we will add some actually visible content to our \code{index.html}. We will use jQuery Mobile and its specialized functions a lot because this CouchApp should be usable with mobile devices.


\subsection{Pages}
\label{3-Interface:pages}
To speed up loading times when switching between different ``windows'' of our CouchApp, we will define \emph{subpages} within our HTML document. So, the complete application layout is already loaded when \code{index.html} is called.
\emph{Subpages} are a speciality of jQuery Mobile and are defined by adding the attribute \code{data-role="page"} to a div-element. These pages can be linked to by a \code{href = \#idOfThePage}. For more information on pages, take a look at \href{http://jquerymobile.com/test/docs/pages/page-anatomy.html}{http://jquerymobile.com/test/docs/pages/page-anatomy.html}.


\subsection{``Tags'' Window}
\label{3-Interface:tags-window}
Let's add our first application window - a view that will list all tags applied to any posts. This is done by defining a \emph{page} inside the \code{\textless{}body\textgreater{}} of our html file (we will use comments to make the start and end of a page more visual):

\begin{Verbatim}[commandchars=\\\{\}]
...
...
\PYG{n+nt}{\textless{}body}\PYG{n+nt}{\textgreater{}}
    \PYG{c}{\textless{}!--}\PYG{c}{ ====== tagListPage =====  }\PYG{c}{--\textgreater{}}
    \PYG{n+nt}{\textless{}div} \PYG{n+na}{data-role=}\PYG{l+s}{"page"} \PYG{n+na}{data-theme=}\PYG{l+s}{"b"} \PYG{n+na}{id=}\PYG{l+s}{"tagListPage"}\PYG{n+nt}{\textgreater{}}

    \PYG{n+nt}{\textless{}/div\textgreater{}}
    \PYG{c}{\textless{}!--}\PYG{c}{ tagListPage }\PYG{c}{--\textgreater{}}
\PYG{n+nt}{\textless{}/body\textgreater{}}
...
...
\end{Verbatim}

Let's take a look at the entry that defines our page \code{\textless{}div data-role="page" data-theme="b" id="tagListPage"\textgreater{}}. As previously said, \code{data-role="page"} defines a new page. By specifying \code{data-theme="b"} we select the jQuery theme named \emph{``b''} for our page. This mainly defines the colour scheme (for more information on this tag, take a look at \href{http://jquerymobile.com/demos/1.0/docs/pages/pages-themes.html}{http://jquerymobile.com/demos/1.0/docs/pages/pages-themes.html}. At last, \code{id="tagListPage"} gives our page a name.

Now, we need to add some content to the ``tagListPage''. Actually, we could just enter some html, but jQuery mobile gives us the possibility to define a \emph{header}, the \emph{content} and a \emph{footer}. This is done again by a \code{\textless{}div\textgreater{}} element with e.g. the attribute \code{data-role="header"}. We should add these three sections to our newly created page:

\begin{Verbatim}[commandchars=\\\{\}]
...
...
\PYG{c}{\textless{}!--}\PYG{c}{ ====== tagListPage =====  }\PYG{c}{--\textgreater{}}
\PYG{n+nt}{\textless{}div} \PYG{n+na}{data-role=}\PYG{l+s}{"page"} \PYG{n+na}{data-theme=}\PYG{l+s}{"b"}\PYG{n+na}{id=}\PYG{l+s}{"tagListPage"}\PYG{n+nt}{\textgreater{}}

    \PYG{n+nt}{\textless{}div} \PYG{n+na}{data-role=}\PYG{l+s}{"header"} \PYG{n+na}{data-position=}\PYG{l+s}{"fixed"}\PYG{n+nt}{\textgreater{}}

    \PYG{n+nt}{\textless{}/div\textgreater{}}
    \PYG{n+nt}{\textless{}div} \PYG{n+na}{data-role=}\PYG{l+s}{"content"} \PYG{n+na}{id=}\PYG{l+s}{"tagListContent"} \PYG{n+nt}{\textgreater{}}

    \PYG{n+nt}{\textless{}/div\textgreater{}}
    \PYG{n+nt}{\textless{}div} \PYG{n+na}{data-role=}\PYG{l+s}{"footer"} \PYG{n+na}{id=}\PYG{l+s}{"tagListFooter"} \PYG{n+na}{data-position=}\PYG{l+s}{"fixed"}\PYG{n+nt}{\textgreater{}}

    \PYG{n+nt}{\textless{}/div\textgreater{}}

\PYG{n+nt}{\textless{}/div\textgreater{}}
\PYG{c}{\textless{}!--}\PYG{c}{ tagListPage }\PYG{c}{--\textgreater{}}
...
...
\end{Verbatim}

For the time being, we just need to enter actual content to the \code{header} and \code{footer}. Data displayed in the \code{content} section will be generated later programmatically.

For the data-role \textbf{header}, fill in:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\textless{}div} \PYG{n+na}{data-role=}\PYG{l+s}{"controlgroup"} \PYG{n+na}{data-type=}\PYG{l+s}{"horizontal"}\PYG{n+nt}{\textgreater{}}
    \PYG{n+nt}{\textless{}a}\PYG{n+nt}{\textgreater{}}0.1.5 select a tag\PYG{n+nt}{\textless{}/a\textgreater{}}
    \PYG{n+nt}{\textless{}a} \PYG{n+na}{href=}\PYG{l+s}{"\PYGZsh{}addPage"} \PYG{n+na}{data-transition=}\PYG{l+s}{"slideup"} \PYG{n+na}{data-role=}\PYG{l+s}{"button"}  \PYG{n+nt}{\textgreater{}}Add Item\PYG{n+nt}{\textless{}/a\textgreater{}}
\PYG{n+nt}{\textless{}/div\textgreater{}}
\end{Verbatim}

The data-role \textbf{footer} has to be filled with:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\textless{}div} \PYG{n+na}{data-role=}\PYG{l+s}{"controlgroup"} \PYG{n+na}{data-type=}\PYG{l+s}{"horizontal"}\PYG{n+nt}{\textgreater{}}
    \PYG{n+nt}{\textless{}a} \PYG{n+na}{href=}\PYG{l+s}{"\PYGZsh{}addPage"} \PYG{n+na}{data-transition=}\PYG{l+s}{"slideup"} \PYG{n+na}{data-role=}\PYG{l+s}{"button"} \PYG{n+nt}{\textgreater{}}Add Item\PYG{n+nt}{\textless{}/a\textgreater{}}
    \PYG{n+nt}{\textless{}a} \PYG{n+na}{href=}\PYG{l+s}{"\PYGZsh{}tagListPage"} \PYG{n+na}{data-transition=}\PYG{l+s}{"slideup"} \PYG{n+na}{data-role=}\PYG{l+s}{"button"} \PYG{n+nt}{\textgreater{}}TagList\PYG{n+nt}{\textless{}/a\textgreater{}}
\PYG{n+nt}{\textless{}/div\textgreater{}}
\end{Verbatim}

If we would push our CouchApp directory tree to our CouchDB right now with the command \code{enotes\$ couchapp push enotes}, we wold generate a CouchApp with the changes we have made so far.
Then, when we would open the link \code{http://localhost:5984/enotes/\_design/enotes/index.html} in our browser, an image like this would be displayed:
\begin{quote}

\includegraphics{3_main.png}
\end{quote}

Here we can see exactly the content of our \code{index.html}. Since we have not added any styling information or program logic, all these are displayed as plain text or hyperlinks. Nothing would happen yet, if we were to click on those links.


\subsection{``List'' Window}
\label{3-Interface:list-window}
When we click on any tag listed, we want to be presented with all notes that are tagged with this specific tag on a new page. This ``list'' window also has to be described in our \code{index.html}. Add the following lines:

\begin{Verbatim}[commandchars=\\\{\}]
...
...
\PYG{c}{\textless{}!--}\PYG{c}{ ====== titleListPage =====  }\PYG{c}{--\textgreater{}}
\PYG{n+nt}{\textless{}div} \PYG{n+na}{data-role=}\PYG{l+s}{"page"} \PYG{n+na}{data-theme=}\PYG{l+s}{"b"}\PYG{n+na}{id=}\PYG{l+s}{"titleListPage"}\PYG{n+nt}{\textgreater{}}

    \PYG{n+nt}{\textless{}div} \PYG{n+na}{data-role=}\PYG{l+s}{"header"} \PYG{n+na}{data-position=}\PYG{l+s}{"fixed"}\PYG{n+nt}{\textgreater{}}
        \PYG{n+nt}{\textless{}h1}\PYG{n+nt}{\textgreater{}}select a note\PYG{n+nt}{\textless{}/h1\textgreater{}}
        \PYG{n+nt}{\textless{}a} \PYG{n+na}{href=}\PYG{l+s}{"\PYGZsh{}addPage"} \PYG{n+na}{data-transition=}\PYG{l+s}{"slideup"} \PYG{n+nt}{\textgreater{}}Add Item\PYG{n+nt}{\textless{}/a\textgreater{}}
        \PYG{n+nt}{\textless{}a} \PYG{n+na}{href=}\PYG{l+s}{"\PYGZsh{}tagListPage"} \PYG{n+na}{data-icon=}\PYG{l+s}{"grid"} \PYG{n+nt}{\textgreater{}}TagList\PYG{n+nt}{\textless{}/a\textgreater{}}
    \PYG{n+nt}{\textless{}/div\textgreater{}}
    \PYG{n+nt}{\textless{}div} \PYG{n+na}{data-role=}\PYG{l+s}{"content"} \PYG{n+na}{id=}\PYG{l+s}{"titleListContent"} \PYG{n+nt}{\textgreater{}}

    \PYG{n+nt}{\textless{}/div\textgreater{}}
    \PYG{n+nt}{\textless{}div} \PYG{n+na}{data-role=}\PYG{l+s}{"footer"} \PYG{n+na}{data-position=}\PYG{l+s}{"fixed"}\PYG{n+nt}{\textgreater{}}
        \PYG{n+nt}{\textless{}a} \PYG{n+na}{href=}\PYG{l+s}{"\PYGZsh{}addPage"} \PYG{n+na}{data-transition=}\PYG{l+s}{"slideup"} \PYG{n+nt}{\textgreater{}}  Add Item  \PYG{n+nt}{\textless{}/a\textgreater{}}
        \PYG{n+nt}{\textless{}a} \PYG{n+na}{href=}\PYG{l+s}{"\PYGZsh{}tagListPage"} \PYG{n+na}{data-icon=}\PYG{l+s}{"grid"} \PYG{n+nt}{\textgreater{}}  TagList   \PYG{n+nt}{\textless{}/a\textgreater{}}
    \PYG{n+nt}{\textless{}/div\textgreater{}}

\PYG{n+nt}{\textless{}/div\textgreater{}}
\PYG{c}{\textless{}!--}\PYG{c}{ titleListPage }\PYG{c}{--\textgreater{}}
...
...
\end{Verbatim}

This defines the layout of the page displaying a list of notes.


\subsection{``Add'' Window}
\label{3-Interface:add-window}
Now, we want to add an additional page to our \code{index.html}. Add the following code inside the \code{\textless{}body\textgreater{}}:

\begin{Verbatim}[commandchars=\\\{\}]
...
...
\PYG{c}{\textless{}!--}\PYG{c}{ ====== add ===== }\PYG{c}{--\textgreater{}}
\PYG{n+nt}{\textless{}div} \PYG{n+na}{data-role=}\PYG{l+s}{"page"} \PYG{n+na}{data-theme=}\PYG{l+s}{"b"} \PYG{n+na}{id=}\PYG{l+s}{"addPage"}\PYG{n+nt}{\textgreater{}}

    \PYG{n+nt}{\textless{}div} \PYG{n+na}{data-role=}\PYG{l+s}{"header"}  \PYG{n+nt}{\textgreater{}}
        \PYG{n+nt}{\textless{}p}\PYG{n+nt}{\textgreater{}}add a single item - addPage\PYG{n+nt}{\textless{}/p\textgreater{}}
        \PYG{n+nt}{\textless{}a} \PYG{n+na}{href=}\PYG{l+s}{"\PYGZsh{}tagListPage"} \PYG{n+na}{data-icon=}\PYG{l+s}{"grid"} \PYG{n+na}{class=}\PYG{l+s}{"ui-btn-right"}\PYG{n+nt}{\textgreater{}}tag list\PYG{n+nt}{\textless{}/a\textgreater{}}
    \PYG{n+nt}{\textless{}/div\textgreater{}}

    \PYG{n+nt}{\textless{}div} \PYG{n+na}{data-role=}\PYG{l+s}{"content"} \PYG{n+na}{id=}\PYG{l+s}{"addContent"} \PYG{n+nt}{\textgreater{}}
        \PYG{n+nt}{\textless{}a}\PYG{n+nt}{\textgreater{}}add content in index.html \PYG{n+nt}{\textless{}/a\textgreater{}}
    \PYG{n+nt}{\textless{}/div\textgreater{}}

    \PYG{n+nt}{\textless{}div} \PYG{n+na}{data-role=}\PYG{l+s}{"footer"} \PYG{n+na}{id=}\PYG{l+s}{"addFooter"} \PYG{n+nt}{\textgreater{}}
        \PYG{n+nt}{\textless{}div} \PYG{n+na}{data-role=}\PYG{l+s}{"controlgroup"} \PYG{n+na}{data-type=}\PYG{l+s}{"horizontal"}\PYG{n+nt}{\textgreater{}}
        \PYG{n+nt}{\textless{}a} \PYG{n+na}{href=}\PYG{l+s}{"\PYGZsh{}tagListPage"} \PYG{n+na}{id=}\PYG{l+s}{"addCancelButton"} \PYG{n+na}{data-role=}\PYG{l+s}{"button"} \PYG{n+na}{data-theme=}\PYG{l+s}{"d"}\PYG{n+nt}{\textgreater{}}Cancel and go to taglist\PYG{n+nt}{\textless{}/a\textgreater{}}
        \PYG{n+nt}{\textless{}input} \PYG{n+na}{type=}\PYG{l+s}{"submit"} \PYG{n+na}{value=}\PYG{l+s}{"add new - Submit"} \PYG{n+na}{data-role=}\PYG{l+s}{"button"} \PYG{n+na}{data-theme=}\PYG{l+s}{"a"}\PYG{n+nt}{\textgreater{}}
        \PYG{n+nt}{\textless{}/div\textgreater{}}
    \PYG{n+nt}{\textless{}/div\textgreater{}}

\PYG{n+nt}{\textless{}/div\textgreater{}}
\PYG{c}{\textless{}!--}\PYG{c}{ add }\PYG{c}{--\textgreater{}}
...
...
\end{Verbatim}

This page is shown when we want to add a new note to our application. When you take a look at the code for the other pages, you will find a link to \code{\#addPage}. This link refers to this very \code{id="addPage}.


\subsection{``Edit'' Window}
\label{3-Interface:edit-window}
To view or edit a note, we also need a special window. Add this code to \code{index.html}:

\begin{Verbatim}[commandchars=\\\{\}]
...
...
\PYG{c}{\textless{}!--}\PYG{c}{ ====== show and edit ===== }\PYG{c}{--\textgreater{}}
\PYG{n+nt}{\textless{}div} \PYG{n+na}{data-role=}\PYG{l+s}{"page"} \PYG{n+na}{data-theme=}\PYG{l+s}{"b"} \PYG{n+na}{id=}\PYG{l+s}{"editPage"}\PYG{n+nt}{\textgreater{}}
    \PYG{c}{\textless{}!--}\PYG{c}{    \textless{}form id="editNote"\textgreater{} }\PYG{c}{--\textgreater{}}
    \PYG{n+nt}{\textless{}div} \PYG{n+na}{data-role=}\PYG{l+s}{"header"}  \PYG{n+nt}{\textgreater{}}
        \PYG{n+nt}{\textless{}p}\PYG{n+nt}{\textgreater{}}edit a single item - editpage\PYG{n+nt}{\textless{}/p\textgreater{}}
        \PYG{n+nt}{\textless{}a} \PYG{n+na}{href=}\PYG{l+s}{"\PYGZsh{}tagListPage"} \PYG{n+na}{data-icon=}\PYG{l+s}{"grid"} \PYG{n+na}{class=}\PYG{l+s}{"ui-btn-right"}\PYG{n+nt}{\textgreater{}}tag list\PYG{n+nt}{\textless{}/a\textgreater{}}
    \PYG{n+nt}{\textless{}/div\textgreater{}}
    \PYG{n+nt}{\textless{}div} \PYG{n+na}{data-role=}\PYG{l+s}{"content"} \PYG{n+na}{id=}\PYG{l+s}{"editContent"} \PYG{n+nt}{\textgreater{}}
        \PYG{n+nt}{\textless{}a}\PYG{n+nt}{\textgreater{}}edit content in index.html \PYG{n+nt}{\textless{}/a\textgreater{}}
    \PYG{n+nt}{\textless{}/div\textgreater{}}
    \PYG{n+nt}{\textless{}div} \PYG{n+na}{data-role=}\PYG{l+s}{"footer"} \PYG{n+na}{id=}\PYG{l+s}{"editFooter"}  \PYG{n+nt}{\textgreater{}}
        \PYG{n+nt}{\textless{}div} \PYG{n+na}{data-role=}\PYG{l+s}{"controlgroup"} \PYG{n+na}{data-type=}\PYG{l+s}{"horizontal"}\PYG{n+nt}{\textgreater{}}
            \PYG{n+nt}{\textless{}a} \PYG{n+na}{op=}\PYG{l+s}{"delete"} \PYG{n+na}{href=}\PYG{l+s}{"\PYGZsh{}titleListPage"} \PYG{n+na}{data-role=}\PYG{l+s}{"button"} \PYG{n+na}{data-theme=}\PYG{l+s}{"b"} \PYG{n+nt}{\textgreater{}}DELETE Note\PYG{n+nt}{\textless{}/a\textgreater{}}
            \PYG{n+nt}{\textless{}a} \PYG{n+na}{href=}\PYG{l+s}{"\PYGZsh{}titleListPage"} \PYG{n+na}{data-role=}\PYG{l+s}{"button"} \PYG{n+na}{data-theme=}\PYG{l+s}{"d"} \PYG{n+nt}{\textgreater{}}Select other Note\PYG{n+nt}{\textless{}/a\textgreater{}}
            \PYG{n+nt}{\textless{}a} \PYG{n+na}{href=}\PYG{l+s}{"\PYGZsh{}addPage"} \PYG{n+na}{data-role=}\PYG{l+s}{"button"} \PYG{n+na}{data-theme=}\PYG{l+s}{"d"} \PYG{n+nt}{\textgreater{}}Add Item\PYG{n+nt}{\textless{}/a\textgreater{}}
            \PYG{n+nt}{\textless{}a} \PYG{n+na}{href=}\PYG{l+s}{"\PYGZsh{}tagListPage"} \PYG{n+na}{data-role=}\PYG{l+s}{"button"} \PYG{n+na}{data-theme=}\PYG{l+s}{"d"} \PYG{n+nt}{\textgreater{}}TagList\PYG{n+nt}{\textless{}/a\textgreater{}}
            \PYG{n+nt}{\textless{}a} \PYG{n+na}{op=}\PYG{l+s}{"save"} \PYG{n+na}{href=}\PYG{l+s}{"\PYGZsh{}titleListPage"}  \PYG{n+na}{data-role=}\PYG{l+s}{"button"} \PYG{n+na}{data-theme=}\PYG{l+s}{"a"} \PYG{n+nt}{\textgreater{}}SAVE Note\PYG{n+nt}{\textless{}/a\textgreater{}}
        \PYG{n+nt}{\textless{}/div\textgreater{}}
    \PYG{n+nt}{\textless{}/div\textgreater{}}
\PYG{n+nt}{\textless{}/div\textgreater{}}
\PYG{c}{\textless{}!--}\PYG{c}{ edit }\PYG{c}{--\textgreater{}}
...
...
\end{Verbatim}

This page is not very different from the others because the actual content within the \code{id=editContent} will be added programmatically.


\subsection{``Error'' Window}
\label{3-Interface:error-window}
The last page we will add is a special window for error messages:

\begin{Verbatim}[commandchars=\\\{\}]
...
...
\PYG{c}{\textless{}!--}\PYG{c}{ ====== error =====  }\PYG{c}{--\textgreater{}}
\PYG{n+nt}{\textless{}div} \PYG{n+na}{data-role=}\PYG{l+s}{"page"} \PYG{n+na}{data-theme=}\PYG{l+s}{"b"} \PYG{n+na}{id=}\PYG{l+s}{"errorPage"}\PYG{n+nt}{\textgreater{}}
    \PYG{n+nt}{\textless{}div} \PYG{n+na}{data-role=}\PYG{l+s}{"header"} \PYG{n+na}{id=}\PYG{l+s}{"errorHeader"} \PYG{n+na}{data-nobackbtn=}\PYG{l+s}{"true"}\PYG{n+nt}{\textgreater{}}
        \PYG{n+nt}{\textless{}a} \PYG{n+na}{href=}\PYG{l+s}{"\PYGZsh{}tagListPage"} \PYG{n+na}{data-icon=}\PYG{l+s}{"grid"} \PYG{n+na}{class=}\PYG{l+s}{"ui-btn-right"}\PYG{n+nt}{\textgreater{}}tag list\PYG{n+nt}{\textless{}/a\textgreater{}}
    \PYG{n+nt}{\textless{}/div\textgreater{}}
    \PYG{n+nt}{\textless{}div} \PYG{n+na}{data-role=}\PYG{l+s}{"content"} \PYG{n+na}{id=}\PYG{l+s}{"errorContent"} \PYG{n+nt}{\textgreater{}}
        error content
    \PYG{n+nt}{\textless{}/div\textgreater{}}
    \PYG{n+nt}{\textless{}div} \PYG{n+na}{data-role=}\PYG{l+s}{"footer"} \PYG{n+na}{id=}\PYG{l+s}{"errorFooter"}  \PYG{n+nt}{\textgreater{}}
        \PYG{n+nt}{\textless{}div} \PYG{n+na}{class=}\PYG{l+s}{"ui-body ui-body-b"}\PYG{n+nt}{\textgreater{}}
            \PYG{n+nt}{\textless{}ul} \PYG{n+na}{class=}\PYG{l+s}{"ui-block-b"}\PYG{n+nt}{\textgreater{}}
                \PYG{n+nt}{\textless{}li}\PYG{n+nt}{\textgreater{}} \PYG{n+nt}{\textless{}a} \PYG{n+na}{href=}\PYG{l+s}{"\PYGZsh{}titleListPage"}  \PYG{n+na}{data-role=}\PYG{l+s}{"button"} \PYG{n+na}{data-theme=}\PYG{l+s}{"d"}\PYG{n+nt}{\textgreater{}}  Select other Note  \PYG{n+nt}{\textless{}/a\textgreater{}} \PYG{n+nt}{\textless{}/li\textgreater{}}
                \PYG{n+nt}{\textless{}li}\PYG{n+nt}{\textgreater{}} \PYG{n+nt}{\textless{}a} \PYG{n+na}{href=}\PYG{l+s}{"\PYGZsh{}addPage"}  \PYG{n+na}{data-role=}\PYG{l+s}{"button"} \PYG{n+na}{data-theme=}\PYG{l+s}{"d"}\PYG{n+nt}{\textgreater{}}   Add Item   \PYG{n+nt}{\textless{}/a\textgreater{}} \PYG{n+nt}{\textless{}/li\textgreater{}}
                \PYG{n+nt}{\textless{}li}\PYG{n+nt}{\textgreater{}} \PYG{n+nt}{\textless{}a} \PYG{n+na}{href=}\PYG{l+s}{"\PYGZsh{}tagListPage"}  \PYG{n+na}{data-role=}\PYG{l+s}{"button"} \PYG{n+na}{data-theme=}\PYG{l+s}{"d"}\PYG{n+nt}{\textgreater{}}   TagList   \PYG{n+nt}{\textless{}/a\textgreater{}} \PYG{n+nt}{\textless{}/li\textgreater{}}
            \PYG{n+nt}{\textless{}/ul\textgreater{}}
        \PYG{n+nt}{\textless{}/div\textgreater{}}
    \PYG{n+nt}{\textless{}/div\textgreater{}}
\PYG{n+nt}{\textless{}/div\textgreater{}}
\PYG{c}{\textless{}!--}\PYG{c}{ error }\PYG{c}{--\textgreater{}}
...
...
\end{Verbatim}


\section{A Look at our CouchApp}
\label{3-Interface:a-look-at-our-couchapp}
If you want to take a look at our CouchApp so far, you have to export the dictionary tree of the CouchApp to CouchDB with: \code{\$enotes couchapp push enotes}. After that, open our application in any web browser with the url \code{http://127.0.0.1:5984/enotes/\_design/enotes/index.html}.
You should see the following page:

\includegraphics{3_final.png}

Since we have not implemented any jQuery or CSS, the content of \code{index.html} is displayed as it is. Each sub page we have entered is rendered at once. This will change with the next chapter.


\chapter{Program Logic}
\label{4-Logic:program-logic}\label{4-Logic::doc}
We just have provided enought code to define a simple interface which does not do anything but display static words right now. To change this, we need to enter some JavaScript code.


\section{Overview}
\label{4-Logic:overview}
To give you an overview of the inner workings of our CouchApp and as a reference, you may refer to the following diagram. Dotted lines represent function calls and normal ones folder relations. Only folders relevant for us are represented, so if you miss e.g. the folders \code{lists}, \code{shows}, \code{updates} or \code{vendor} don't wonder.

\includegraphics{graphviz-5b8faf4b99150f50dde74e38995cdbe547353b00.pdf}


\section{StartUp Code}
\label{4-Logic:startup-code}
First, we need some code that initializes our application. We stay at our HTML file and add the following lines to the end of the file (but still within the \code{\textless{}html\textgreater{}})

\begin{Verbatim}[commandchars=\\\{\}]
    ...
    ...
    \PYG{n+nt}{\textless{}/body\textgreater{}}
    \PYG{n+nt}{\textless{}script }\PYG{n+na}{src=}\PYG{l+s}{"vendor/couchapp/loader.js"}\PYG{n+nt}{\textgreater{}}\PYG{n+nt}{\textless{}/script\textgreater{}}
    \PYG{n+nt}{\textless{}script }\PYG{n+na}{src=}\PYG{l+s}{"logic.js"}\PYG{n+nt}{\textgreater{}}\PYG{n+nt}{\textless{}/script\textgreater{}}
\PYG{n+nt}{\textless{}/html\textgreater{}}
\end{Verbatim}

This code will execute two java scripts after loading the HTML page. One stored at \code{vendor/couchapp/loader.js} and the other one just called \code{logic.js}. Since we refer to these files, we will create them now.


\subsection{loader.js}
\label{4-Logic:loader-js}
This file is located inside the \code{vendor} directory of our CouchApp tree. So, let's navigate to this folder and enter the subfolder called \code{couchapp}. Here you see an additional directory called \code{\_attachments}. This one holds all files which are attached to the design document of our CouchApp under the context of ``vendor''. Its exactly the same as the default ``\_attachments'' directory at our base with the difference that these files are uploaded within the ``vendors'' field.
We create the empty file \code{loader.js} at this location and open it with a text editor.

Enter the following function to the file:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{n+nx}{couchapp\PYGZus{}load}\PYG{p}{(}\PYG{n+nx}{scripts}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kd}{var} \PYG{n+nx}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n+nx}{i} \PYG{o}{\textless{}} \PYG{n+nx}{scripts}\PYG{p}{.}\PYG{n+nx}{length}\PYG{p}{;} \PYG{n+nx}{i}\PYG{o}{++}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nb}{document}\PYG{p}{.}\PYG{n+nx}{write}\PYG{p}{(}\PYG{l+s+s1}{'\textless{}script src="'}\PYG{o}{+}\PYG{n+nx}{scripts}\PYG{p}{[}\PYG{n+nx}{i}\PYG{p}{]}\PYG{o}{+}\PYG{l+s+s1}{'"\textgreater{}\textless{}\PYGZbs{}/script\textgreater{}'}\PYG{p}{)}
    \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

This function takes an array as argument (\code{scripts}) which holds a list of libraries. These libraries then are formatted to represent HTML calls and are injected into the HTML from where this function was called (in your case, into \code{index.html}). Thereby, these JavaScript libraries are loaded themselves.

But for the function to do anything it must not only be defined, but also be called. So, let's call it. After the function definition, insert:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n+nx}{couchapp\PYGZus{}load}\PYG{p}{(}\PYG{p}{[}
    \PYG{l+s+s2}{"/\PYGZus{}utils/script/sha1.js"}\PYG{p}{,}
    \PYG{l+s+s2}{"/\PYGZus{}utils/script/json2.js"}\PYG{p}{,}
    \PYG{l+s+s2}{"/\PYGZus{}utils/script/jquery.js"}\PYG{p}{,}

    \PYG{l+s+s2}{"vendor/couchapp/jquery-1.6.2.min.js"}\PYG{p}{,}

    \PYG{l+s+s2}{"vendor/couchapp/jquery.couch.js"}\PYG{p}{,}
    \PYG{l+s+s2}{"vendor/couchapp/jquery.couch.app.js"}\PYG{p}{,}
    \PYG{l+s+s2}{"vendor/couchapp/jquery.couch.app.util.js"}\PYG{p}{,}

    \PYG{l+s+s2}{"vendor/couchapp/jquery.pathbinder.js"}\PYG{p}{,}
    \PYG{l+s+s2}{"vendor/couchapp/jquery.mustache.js"}\PYG{p}{,}
    \PYG{l+s+s2}{"vendor/couchapp/jquery.evently.js"}\PYG{p}{,}

    \PYG{l+s+s2}{"vendor/couchapp/jquery-ui-1.8.11.custom.min.js"}\PYG{p}{,}
    \PYG{l+s+s2}{"vendor/couchapp/jquery.mobile-1.0.min.js"}
\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

This last code consists of the function call \code{couchapp\_load} and an array of libraries to be loaded. So, when the file \code{loader.js} is opened from our HTML file, exactly this happens. The order in which these libraries are loaded is important since some of them depend on each other and cannot be loaded properly if the files they depend on have not already been loaded.

Let's review these libraries and copy the ones still missing to \code{vendor/couchapp/\_attachments/}:

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{
file
} & \textbf{
explanation
} & \textbf{
where to get
}\\
\hline

\code{/\_utils/*.*}
 & 
They refer to files already available within CouchDB. Remember,
the path \code{/\_utils/} points to the CouchDB user interface when
used within a web browser.
 & 
already present
\\

\code{jquery.couch.js}
 & 
Comes with every CouchDB installation and offers a JavaScript
interface for the CouchApp.
 & 
find it with a file search tool on your system
\\

\code{jquery-ui*.min.js}
 & 
The actual name of this file depends on the version of CouchDB
you have installed. You have to change the entry in \code{loader.js}
accordingly!
 & 
find it with a file search tool on your system
\\

\code{jquery-1.6.2.min.js}
 & 
This is the actual jQuery library.
 & 
\code{Download a working copy here}
or go to
\href{http://docs.jquery.com/Downloading\_jQuery}{http://docs.jquery.com/Downloading\_jQuery}
\\

\code{jquery.mobile-1.0.min.js}
 & 
The mobile version of jQuery. A newer version than the one
proposed here may also work for you.
 & 
\code{Download here}
or find it at
\href{http://jquerymobile.com/download/}{http://jquerymobile.com/download/}
\\

\code{jquery.pathbinder.js}
 & 
We need this file to use evently functions stored in the CouchApp
directory tree.
 & 
\code{Download here}
\\

\code{jquery.evently.js}
 & 
Evently bindings
 & 
\code{Download here}
\\

other files
 & 
All other files are already present.
 & \\
\hline
\end{tabulary}


If we export our CouchApp to our CouchDB again (\code{enotes\$ couchapp push enotes}) and open the exported CouchApp (\code{http://localhost:5984/enotes/\_design/enotes/index.html}), we will see that the appearance of the \code{index.html} has changed.
\begin{quote}

\includegraphics{4_jQuery.png}
\end{quote}

This change has happened solely because of the reference to the additional JavaScript libraries. The reason the graphics have been added is due to jQuery. In our \code{index.html} we have already set certain attributes that tell jQuery how to design the elements (like for example hyperlinks as buttons).

If you click on the button in the lower right labeled ``Add Item'', our ``Add Item'' subpage is shown. This happens, because the hyperlink behind this button links to \code{\#addPage}. jQuery interpretes this link and loads the subpage with the id ``addPage''.


\subsection{logic.js}
\label{4-Logic:logic-js}
Finally, the file \code{logic.js} handles the program logic unique to our application. Here the functions are defined or linked to, that are executed when a certain event is triggered in our HTML file.

Since it does not exist yet, we have to create it. It should be located at \code{/\_attachments/logic.js}. Now, lets fill in some code!

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nx}{\PYGZdl{}dbname} \PYG{o}{=} \PYG{l+s+s2}{"enotes"}\PYG{p}{;}
\PYG{n+nx}{\PYGZdl{}appname}\PYG{o}{=} \PYG{l+s+s2}{"enotes"}\PYG{p}{;}
\PYG{n+nx}{\PYGZdl{}db} \PYG{o}{=} \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{couch}\PYG{p}{.}\PYG{n+nx}{db}\PYG{p}{(}\PYG{n+nx}{\PYGZdl{}dbname}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"body"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{data} \PYG{o}{=}    \PYG{p}{\PYGZob{}} \PYG{l+s+s2}{"tagSelected"} \PYG{o}{:} \PYG{l+s+s2}{"NOTAG"}
                \PYG{p}{,} \PYG{l+s+s2}{"idSelected"} \PYG{o}{:} \PYG{l+m+mi}{0}
                \PYG{p}{,} \PYG{l+s+s2}{"docEdited"} \PYG{o}{:} \PYG{l+s+s2}{""}
                \PYG{p}{,} \PYG{l+s+s2}{"tagsUsed"}  \PYG{o}{:} \PYG{p}{[}\PYG{p}{]}
                \PYG{p}{,} \PYG{l+s+s2}{"textSearchString"} \PYG{o}{:} \PYG{k+kc}{false}
                \PYG{p}{,} \PYG{l+s+s2}{"titleSearchString"} \PYG{o}{:} \PYG{k+kc}{false}
                \PYG{p}{,} \PYG{l+s+s2}{"tagSelected"} \PYG{o}{:} \PYG{k+kc}{false}
                \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

This first part creates the variables \code{\$dbname}, \code{\$appname} and \code{\$db}. As you may have guessed, the first two entries denote the name of the database we are using and the second one states the name of our CouchApp. The third variable defines our database connection. \code{\$.couch.db(\$dbname)} is a method that is located within the file \code{/vendor/couchapp/\_attachments/jquery.couch.js}.
The command \code{\$("body").data} is a jQuery specific method. It attaches any information in JSON format to a given DOM element. In our case it is the \code{body} element this information is attached to. This defines the initial state our CouchApp is in when it is started.

We will go on by adding the following lines to the same file:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{couch}\PYG{p}{.}\PYG{n+nx}{app}\PYG{p}{(}\PYG{k+kd}{function} \PYG{p}{(}\PYG{n+nx}{app}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"\PYGZsh{}addContent"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{evently}\PYG{p}{(}\PYG{l+s+s2}{"editContent"}\PYG{p}{,} \PYG{n+nx}{app}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"\PYGZsh{}addPage"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{evently}\PYG{p}{(}\PYG{l+s+s2}{"addPage"}\PYG{p}{,} \PYG{n+nx}{app}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"\PYGZsh{}tagListPage"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{evently}\PYG{p}{(}\PYG{l+s+s2}{"tagListPage"}\PYG{p}{,} \PYG{n+nx}{app}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"\PYGZsh{}tagListContent"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{evently}\PYG{p}{(}\PYG{l+s+s2}{"tagListContent"}\PYG{p}{,} \PYG{n+nx}{app}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"\PYGZsh{}titleListPage"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{evently}\PYG{p}{(}\PYG{l+s+s2}{"titleListPage"}\PYG{p}{,} \PYG{n+nx}{app}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"\PYGZsh{}titleListContent"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{evently}\PYG{p}{(}\PYG{l+s+s2}{"titleListContent"}\PYG{p}{,} \PYG{n+nx}{app}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"\PYGZsh{}editPage"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{evently}\PYG{p}{(}\PYG{l+s+s2}{"editPage"}\PYG{p}{,} \PYG{n+nx}{app}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"\PYGZsh{}editContent"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{evently}\PYG{p}{(}\PYG{l+s+s2}{"editContent"}\PYG{p}{,} \PYG{n+nx}{app}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

The functions we just called links certain links inside the HTML file (like \code{\#addPage}) to evently events. At this point we only add links to eight functions. For our CouchApp to work properly, we will come back here to add some more links later on.
Notice that both \code{\#addContent} and \code{\#editContent} link to the same element (\code{editContent}) since they will use the same method and layout to display information.


\section{Action Code / Evently}
\label{4-Logic:action-code-evently}
Now we will add some code that is only executed when certain events are triggered (like clicking on a hyperlink). We will use evently to help us organise these event-based functions, but also have to add certain pieces of code to other places.

As we have encountered before, CouchApps are organised by maintaining a directory tree. This directory tree represents hierarchies. We can define functions for evently by storing these in the \code{evently} sub folder, we will create right now. Each function is located at a folder of its own inside the \code{evently} directory and replaces any already available function with the same name.

At the beginning of every chapter you will be presented with a diagram of folders and files you have to create. If you get confused during the passages of text you can refer to this graphics to reorientate.


\subsection{addPage - Event}
\label{4-Logic:addpage-event}
\includegraphics{graphviz-6a46964039e68258669ffe6a460894096c0784af.pdf}

There has to be added a folder for our \code{addPage} link inside the \code{evently} folder. Inside this \code{addPage} folder we will create a file named \code{pagebeforeshow.js}. As the name tells us, the content within this file is executed before a specific page is shown. Fill it with the following code:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{p}{(}\PYG{n+nx}{data}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"evently/addPage/pagebeforeshow.js"} \PYG{o}{+} \PYG{n+nx}{data}\PYG{p}{)}
        \PYG{c+c1}{// indicates 'new note'}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"body"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{idSelected} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"\PYGZsh{}addContent"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{trigger}\PYG{p}{(}\PYG{l+s+s2}{"shownote"}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n+nx}{data}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

This mainly calles the function \code{shownote} from the element \code{addContent} (which is linked to an evently event named \code{editContent}. This does not yet exist, but we will create it soon).

Now, we have to add some more folders. Inside the \code{addPage} directory, we have to create a folder with the name \code{\_init}. This stands for the init-function that is executed when the function is loaded. Here, add another folder named \code{selectors}. The content of this new folder describes DOM elements to which content added further on applies to. We will add a directory named \code{input} inside the \code{selectors} folder. Now, inside \code{input}, create a file with the name \code{click.js}.
This directory structure will be interpreted as a jQuery function by the couchapp application. It would look like this: \code{\$("input").click}.

At last, we can define the function that is executed when a click happens to the ``input'' element our directory structure referres to. We do this by adding the following code to \code{click.js}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"addPage - shownote - click.js"}\PYG{p}{)}\PYG{p}{;}

        \PYG{k+kd}{var} \PYG{n+nx}{docvalue}\PYG{o}{=} \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"body"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{docEdited}\PYG{p}{;} \PYG{c+c1}{//edata.docEdited;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nx}{docvalue}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kd}{var}
                \PYG{n+nx}{title} \PYG{o}{=} \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s1}{'input[name=title]'}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{val}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                \PYG{n+nx}{text} \PYG{o}{=} \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s1}{'textarea\PYGZsh{}editTextField'}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{val}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                \PYG{n+nx}{tags} \PYG{o}{=} \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s1}{'input[name=tags]'}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{val}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{split}\PYG{p}{(}\PYG{l+s+s2}{" "}\PYG{p}{)}\PYG{p}{;}

        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"body"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{tagSelected}\PYG{o}{=}\PYG{n+nx}{tags}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{.}\PYG{n+nx}{toUpperCase}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

        \PYG{k+kd}{var} \PYG{n+nb}{document} \PYG{o}{=} \PYG{p}{\PYGZob{}}
                \PYG{l+s+s2}{"type"} \PYG{o}{:} \PYG{l+s+s2}{"note"}\PYG{p}{,} \PYG{l+s+s2}{"TextNote"} \PYG{o}{:} \PYG{p}{\PYGZob{}}
                        \PYG{l+s+s2}{"note"} \PYG{o}{:} \PYG{p}{\PYGZob{}}
                                \PYG{l+s+s2}{"title"}\PYG{o}{:} \PYG{n+nx}{title}\PYG{p}{,} \PYG{l+s+s2}{"text"} \PYG{o}{:} \PYG{n+nx}{text}\PYG{p}{,} \PYG{l+s+s2}{"tags"} \PYG{o}{:} \PYG{n+nx}{tags}
                        \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}\PYG{p}{;}
        \PYG{c+c1}{//no fields for docid and docrev in 'addpage' which is new doc}
        \PYG{c+c1}{// could check docvalue.\PYGZus{}id = 0}

        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nb}{document}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{doStoreDocument}\PYG{p}{(}\PYG{n+nb}{document}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//braucht das alte doc fuer die revision?}

        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"addPage after store"}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nb}{document}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"\PYGZsh{}editContent"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{trigger}\PYG{p}{(}\PYG{l+s+s2}{"shownote"}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{//possible an argument, how to use?}
        \PYG{c+c1}{//      the saving of the id comes too late, async issue}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{mobile}\PYG{p}{.}\PYG{n+nx}{changePage}\PYG{p}{(}\PYG{l+s+s2}{"\PYGZsh{}titleListPage"}\PYG{p}{,} \PYG{l+s+s2}{"slidedown"}\PYG{p}{,} \PYG{k+kc}{true}\PYG{p}{,} \PYG{k+kc}{true}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// id is found too late}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Take a look at the line \code{\$("\#editContent").trigger("shownote");}. Here, the function \code{shownote} which is linked to \code{\#editContent} is called.
Since this function does not yet exist, we have to add a second event to the \code{evently} folder called \code{editContent} (remember our \code{logic.js} - there we assign the function \code{editContent} to the link \code{\#addContent}). The actual link \code{\#addContent} that calls the function \code{editContent} is located in \code{index.html} inside the \code{addPage} page.
To create this function, again make a folder called \code{editContent} inside our \code{evently} folder. Within this new folder we create another directory called \code{shownote} - this is the name of our function.
Within this directory create the following files with the following content:
\begin{itemize}
\item {} 
\textbf{data.js}: We can see that the content of a stored note is loaded into the variable \code{noteContent}:
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{p}{(}\PYG{n+nx}{data}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k+kd}{var} \PYG{n+nx}{note}\PYG{p}{;}
    \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"evently/editContent/shownote/data.js"}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nx}{data}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"bdoy"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{docEdited}\PYG{o}{=}\PYG{n+nx}{data}\PYG{p}{;}
    \PYG{k+kd}{var} \PYG{n+nx}{noteContent}\PYG{o}{=}\PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{TextNote}\PYG{p}{.}\PYG{n+nx}{note}\PYG{p}{;}
    \PYG{n+nx}{noteContent}\PYG{p}{.}\PYG{n+nx}{taglist}\PYG{o}{=}\PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{TextNote}\PYG{p}{.}\PYG{n+nx}{note}\PYG{p}{.}\PYG{n+nx}{tags}\PYG{p}{.}\PYG{n+nx}{join}\PYG{p}{(}\PYG{l+s+s2}{" "}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nx}{noteContent}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"put doc in docEdited"}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n+nx}{noteContent}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
\end{quote}

\item {} 
\textbf{async.js}: Within this code, remember the call for the function \code{makeEmptyNote()} - we will add it later on.
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function}\PYG{p}{(}\PYG{n+nx}{callback}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k+kd}{var} \PYG{n+nx}{idvalue}\PYG{o}{=}\PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"body"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{idSelected}\PYG{p}{;}
    \PYG{k+kd}{var} \PYG{n+nx}{emptydata} \PYG{o}{=} \PYG{n+nx}{makeEmptyNote}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"evently/editContent/shownote/async.js: edit content - id is found "} \PYG{o}{+} \PYG{n+nx}{idvalue}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"body"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{tagSelected}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nx}{emptydata}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n+nx}{idvalue} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                        \PYG{n+nx}{doGetDoc} \PYG{p}{(}\PYG{n+nx}{idvalue}\PYG{p}{,} \PYG{n+nx}{callback}\PYG{p}{)}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
    \PYG{k}{else} \PYG{p}{\PYGZob{}}\PYG{n+nx}{callback} \PYG{p}{(}\PYG{n+nx}{emptydata}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
\end{quote}

\item {} 
\textbf{mustache.html}:
\begin{quote}

\begin{Verbatim}[commandchars=@\[\]]
@textless[]div@textgreater[]
    @textless[]!-- @textless[]p@textgreater[] mustache of editContent/@_init id= {{@_id}} rev= {{@_rev}} @textless[]/p@textgreater[] --@textgreater[]
    @textless[]a class=docidrev "docid"={{@_id}}  "docrev"={{@_rev}} /@textgreater[]
    @textless[]div data-role="fieldcontain"@textgreater[]
        @textless[]label for="title"@textgreater[]Title:@textless[]/label@textgreater[]
        @textless[]input id="editTitleField" name="title" type="text" data-role="none"
            value="{{title}}" @textgreater[]
    @textless[]/div@textgreater[]
    @textless[]div data-role="fieldcontain"@textgreater[]
        @textless[]label for="text"@textgreater[]Text:@textless[]/label@textgreater[]
        @textless[]textarea id="editTextField" name="text" cols="40" rows="8" @textgreater[]{{text}}
        @textless[]/textarea@textgreater[]
    @textless[]/div@textgreater[]
    @textless[]div data-role="fieldcontain" class="ui-widget@textgreater[]
        @textless[]label for="tags"@textgreater[]Tags:@textless[]/label@textgreater[]
        @textless[]input id="editTagsField" name="tags" type="text" data-role="none"
            value="{{taglist}}" /@textgreater[]
    @textless[]/div@textgreater[]
@textless[]/div@textgreater[]
\end{Verbatim}
\end{quote}

\item {} 
\textbf{after.js}:
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{p}{(}\PYG{n+nx}{data}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k+kd}{function} \PYG{n+nx}{split}\PYG{p}{(} \PYG{n+nx}{val} \PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nx}{val}\PYG{p}{.}\PYG{n+nx}{split}\PYG{p}{(} \PYG{l+s+sr}{/,\PYGZbs{}s*/} \PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"evently/shownote/after.js"} \PYG{o}{+} \PYG{n+nx}{data}\PYG{p}{)}
    \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nx}{data}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kd}{var} \PYG{n+nx}{thetags}\PYG{o}{=}\PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"body"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{tagsUsed}\PYG{p}{;}
    \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nx}{thetags}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"\PYGZsh{}editTagsField"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{autocomplete}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n+nx}{source}\PYG{o}{:}\PYG{n+nx}{thetags}\PYG{p}{,}
        \PYG{n+nx}{max}\PYG{o}{:} \PYG{l+m+mi}{6}\PYG{p}{,}
        \PYG{n+nx}{highlightItem}\PYG{o}{:} \PYG{k+kc}{true}\PYG{p}{,}
        \PYG{n+nx}{multiple}\PYG{o}{:} \PYG{k+kc}{true}\PYG{p}{,}
        \PYG{n+nx}{multipleSeparator}\PYG{o}{:} \PYG{l+s+s2}{" "}
        \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n+nx}{data}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
\end{quote}

\end{itemize}

Since the titleListPage is referred to in the \code{click.js} function of the \code{addPage} event, we need to add the folder \code{titleListPage} to the \code{evently} folder. There create the file \code{pagebeforeshow.js} and fill it with the following code:

\begin{Verbatim}[commandchars=\\\{\}]
    \PYG{k+kd}{function} \PYG{p}{(}\PYG{n+nx}{data}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"evently/titleListPage/pagebeforeshow.js"} \PYG{o}{+} \PYG{n+nx}{data}\PYG{p}{)}\PYG{p}{;}
            \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nx}{data}\PYG{p}{)}\PYG{p}{;}
            \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"\PYGZsh{}titleListContent"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{trigger}\PYG{p}{(}\PYG{l+s+s2}{"updateTitleList"}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{return} \PYG{n+nx}{data}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
\begin{quote}

As we can see, the funcion \code{updateTitleList} from the object \code{titleListContent} ist called. We have to create this folder. So, inside \code{evently} create a directory named \code{titleListContent}. Within that make another one called \code{updateTitleList}. Inside this directory, create one named \code{selectors} and then one named \code{a}. Finally, within that one make a file called \code{click.js} and fill it with the following code:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function}\PYG{p}{(}\PYG{n+nx}{event}\PYG{p}{,} \PYG{n+nx}{name}\PYG{p}{,} \PYG{n+nx}{pass}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k+kd}{var} \PYG{n+nx}{target} \PYG{o}{=} \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{n+nx}{event}\PYG{p}{.}\PYG{n+nx}{target}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"selectNote in evently/titleListContent/updateTitleList/selectors/a"}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n+nx}{target}\PYG{p}{.}\PYG{n+nx}{is}\PYG{p}{(}\PYG{l+s+s1}{'a'}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k+kd}{var} \PYG{n+nx}{idval} \PYG{o}{=} \PYG{n+nx}{target}\PYG{p}{.}\PYG{n+nx}{attr}\PYG{p}{(}\PYG{l+s+s2}{"id"}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"body"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{idSelected}\PYG{o}{=}\PYG{n+nx}{idval}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
\end{quote}

Back in the \code{updateTitleList} folder (take a look at the graphic at the beginning of this section if you got lost), we have to add some files quite different from the last time:
\begin{itemize}
\item {} 
\textbf{data.js}: This file is the main component of events. Here, data specific action is taking place. Usually, one would refer to a CochDB view or gather data otherwise here. In our case, the autocompletion field (which itslef is defined in the file \code{mustache.html}) is set up.
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
    \PYG{k+kd}{function} \PYG{p}{(}\PYG{n+nx}{data}\PYG{p}{)} \PYG{p}{\PYGZob{}}
\PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"evently/titleListContent/updateTitleList/data.js"}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kd}{var} \PYG{n+nx}{tag} \PYG{o}{=}  \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"body"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{tagSelected}\PYG{p}{;}
\PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{key} \PYG{o}{=} \PYG{n+nx}{tag}\PYG{p}{;}
\PYG{k}{return}  \PYG{n+nx}{data}\PYG{p}{;}
\end{Verbatim}

\}
\end{quote}

\item {} 
\textbf{async.js}:
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function}\PYG{p}{(}\PYG{n+nx}{callback}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"evently/titleListContent/updateTitleList/async.js"} \PYG{p}{)}\PYG{p}{;}
    \PYG{k+kd}{var} \PYG{n+nx}{tag} \PYG{o}{=} \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"body"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{tagSelected}\PYG{p}{;}
    \PYG{k+kd}{var} \PYG{n+nx}{titleWord} \PYG{o}{=} \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"body"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{titleSearchString}\PYG{p}{;}
    \PYG{k+kd}{var} \PYG{n+nx}{textWord} \PYG{o}{=} \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"body"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{textSearchString}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n+nx}{tag}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{doView} \PYG{p}{(}\PYG{l+s+s2}{"DocbyTag2"}\PYG{p}{,} \PYG{p}{\PYGZob{}} \PYG{l+s+s2}{"key"}\PYG{o}{:}\PYG{n+nx}{tag}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n+nx}{callback}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n+nx}{titleWord}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{n+nx}{doView} \PYG{p}{(}\PYG{l+s+s2}{"byTitleWord"}\PYG{p}{,}
            \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{"reduce"} \PYG{o}{:}\PYG{k+kc}{false}\PYG{p}{,} \PYG{l+s+s2}{"key"}\PYG{o}{:}\PYG{n+nx}{titleWord}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n+nx}{callback}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n+nx}{textWord}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{n+nx}{doView} \PYG{p}{(}\PYG{l+s+s2}{"byTextWord"}\PYG{p}{,}
            \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{"reduce"} \PYG{o}{:} \PYG{k+kc}{false}\PYG{p}{,} \PYG{l+s+s2}{"key"} \PYG{o}{:} \PYG{n+nx}{textWord}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n+nx}{callback}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
\end{quote}

\item {} 
\textbf{mustache.html}: Here the layout of the editPage/addPage is defined. Fill it with the following code.
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\textless{}ul} \PYG{n+na}{id=}\PYG{l+s}{"titleslist"} \PYG{n+na}{data-role=}\PYG{l+s}{"listview"}\PYG{n+nt}{\textgreater{}}
    \PYGZob{}\PYGZob{}\PYGZsh{}rows\PYGZcb{}\PYGZcb{}
        \PYG{n+nt}{\textless{}li}\PYG{n+nt}{\textgreater{}}
        \PYGZob{}\PYGZob{}\PYGZsh{}value\PYGZcb{}\PYGZcb{}
        \PYG{n+nt}{\textless{}a} \PYG{n+na}{class=}\PYG{l+s}{"title"} \PYG{n+na}{href=}\PYG{l+s}{"\PYGZsh{}editPage"} \PYG{n+na}{id=}\PYG{l+s}{\PYGZob{}\PYGZob{}\PYGZus{}id\PYGZcb{}\PYGZcb{}} \PYG{n+nt}{\textgreater{}}
        \PYGZob{}\PYGZob{}\PYGZsh{}TextNote\PYGZcb{}\PYGZcb{}
        \PYGZob{}\PYGZob{}\PYGZsh{}note\PYGZcb{}\PYGZcb{}
              \PYGZob{}\PYGZob{}title\PYGZcb{}\PYGZcb{}
        \PYGZob{}\PYGZob{}/note\PYGZcb{}\PYGZcb{}
        \PYGZob{}\PYGZob{}/TextNote\PYGZcb{}\PYGZcb{}
         \PYG{n+nt}{\textless{}/a\textgreater{}}
        \PYGZob{}\PYGZob{}/value\PYGZcb{}\PYGZcb{}
        \PYG{n+nt}{\textless{}/li\textgreater{}}
    \PYGZob{}\PYGZob{}/rows\PYGZcb{}\PYGZcb{}
\PYG{n+nt}{\textless{}/ul\textgreater{}}
\end{Verbatim}
\end{quote}

\end{itemize}

Remember, anything between \code{\{\{{}`{}`{}`and {}`{}`\}\}} will be replaced by the corresponding JSON value when this file is used later on.
\begin{itemize}
\item {} 
\textbf{after.js}:
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{p}{(}\PYG{n+nx}{data}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"evently/titleListContent/updateTitleList/after.js"} \PYG{p}{)}
    \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"\PYGZsh{}titleslist"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{listview}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"after listview  "}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n+nx}{data}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
\end{quote}

\end{itemize}

We are calling a JavaScript function called \code{makeEmptyNote} in our code here. This does not yet exist, so we have to create it. It should be located in \code{logic.js} inside our \code{/\_attachments} folder. Just open this file and add the following lines to it at the bottom:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{n+nx}{makeEmptyNote} \PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"logic.js - makeEmptyNote"}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kd}{var} \PYG{n+nx}{emptynote} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{"\PYGZus{}id"} \PYG{o}{:}  \PYG{l+s+s2}{""}
                \PYG{p}{,} \PYG{l+s+s2}{"\PYGZus{}rev"} \PYG{o}{:} \PYG{l+s+s2}{""}
                \PYG{p}{,} \PYG{l+s+s2}{"type"} \PYG{o}{:} \PYG{l+s+s2}{"note"}
                \PYG{p}{,} \PYG{l+s+s2}{"TextNote"} \PYG{o}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{"note"} \PYG{o}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{"title"}\PYG{o}{:} \PYG{l+s+s2}{""}
                        \PYG{p}{,} \PYG{l+s+s2}{"text"} \PYG{o}{:} \PYG{l+s+s2}{""}
                        \PYG{p}{,} \PYG{l+s+s2}{"tags"} \PYG{o}{:} \PYG{p}{[}\PYG{p}{]}
                \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}\PYG{p}{;}
        \PYG{k}{return} \PYG{n+nx}{emptynote}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

If we were to take a look at our CouchApp right now and would add a new note, we would see the following:

\includegraphics{4_add.png}


\subsection{Save Notes}
\label{4-Logic:save-notes}
To be able to save a new note, we have to click on the ``add new - Submit'' button. But this does not work yet, because we are still missing code to save our entry. When the page is loaded, the code in \code{evently/addPage/\_init/selectors/input} is attached to each input-type element. Therefore, if we click on the button, the code stored within the \code{click.js} file we edited earlier is fired. There is exactly one very important line in this code, namely \code{doStoreDocument(document);}. This is a function call of another function that still has to be included in our \code{logic.js}. So lets add the following code to \code{logic.js} inside our \code{/\_attachments} directory:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{n+nx}{doStoreDocument}\PYG{p}{(}\PYG{n+nb}{document}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{\PYGZdl{}db}\PYG{p}{.}\PYG{n+nx}{saveDoc}\PYG{p}{(}\PYG{n+nb}{document}\PYG{p}{,} \PYG{p}{\PYGZob{}}
                \PYG{n+nx}{async} \PYG{o}{:} \PYG{k+kc}{false}\PYG{p}{,}
                \PYG{n+nx}{success}\PYG{o}{:} \PYG{k+kd}{function} \PYG{p}{(}\PYG{n+nx}{data}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"body"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{docEdited} \PYG{o}{=} \PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{id}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"store - success"} \PYG{o}{+} \PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{id} \PYG{o}{+} \PYG{l+s+s2}{" "} \PYG{o}{+}  \PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{rev}\PYG{p}{)}\PYG{p}{;}
                        \PYG{c+c1}{//  \PYGZdl{}.mobile.changePage("\PYGZsh{}editPage", "slidedown", true, true);}
                \PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{n+nx}{error}\PYG{o}{:} \PYG{k+kd}{function} \PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{alert}\PYG{p}{(}\PYG{l+s+s2}{"Cannot save new document."}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Here a CouchDB specific function (\code{\$db.saveDoc(document, \{}) is called on the \code{\$db} object AJAX style to actually do the saving.


\subsection{Review the Document}
\label{4-Logic:review-the-document}
I encourage you to export our CouchApp (\code{enotes couchapp push enotes}) and open it in your web-browser. Now, create a new note inside our running CouchApp and save it. Don't be shocked if you won't see it afterwards in the list of available notes or get any error messages in a debug window - if you use any (this code is still to be implemented). What I want to show you now is the actual document that was saved into our CouchDB by clicking on ``add new - Submit''.
In the web browser, open the page \href{http://127.0.0.1:5984/\_utils/database.html?enotes}{http://127.0.0.1:5984/\_utils/database.html?enotes} .
There you will not only find our \code{\_design/enotes} document, but also another one with random ID. Click on it to see its content.

\includegraphics{4_document.png}

As we can see, this is the document that holds our new note.

Now, we have to make it visible in our CouchApp. So far, we can create new notes, but cannot look at them.


\subsection{List used Tags}
\label{4-Logic:list-used-tags}
\includegraphics{graphviz-0073b2456451e7a0c5275945d8a5a28cdd86f1af.pdf}

We want the list of available notes to be refreshed every time the main page is shown. The main page is the one with \code{id=tagListContent} which shows all notes available grouped by tags. To accieve this, we need again some evently code and a specific CouchDB view that groups our notes according to their tags.

First, we create a new folder in our \code{evently} folder named \code{tagListPage}. Within this new folder, create a file called \code{pagebeforeshow.js}. This code is executed right before our ``tagListPage'' is shown. Insert:

\begin{Verbatim}[commandchars=\\\{\}]
    \PYG{k+kd}{function} \PYG{p}{(}\PYG{n+nx}{data}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"evently/tagListPage/pagebeforeshow.js"} \PYG{o}{+} \PYG{n+nx}{data}\PYG{p}{)}
            \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nx}{data}\PYG{p}{)}\PYG{p}{;}
            \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"\PYGZsh{}tagListContent"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{trigger}\PYG{p}{(}\PYG{l+s+s2}{"\PYGZus{}init"}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// ("updateTagList" );}
            \PYG{k}{return} \PYG{n+nx}{data}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

As we can see, the event \code{\_init} of the object \code{tagListContent} is called. We will add this function shortly. But first, create an additional directory named \code{selectors} and then, inside the one before, one called \code{a}. Within \code{a} create a file called \code{click.js}. Fill it with the following code:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function}\PYG{p}{(}\PYG{n+nx}{event}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k+kd}{var} \PYG{n+nx}{target} \PYG{o}{=} \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{n+nx}{event}\PYG{p}{.}\PYG{n+nx}{currentTarget}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//probably currentTarget needed because this is a button}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"tagListPage - selectors - a -click.js "}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nx}{event}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nx}{target}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kd}{var} \PYG{n+nx}{aid} \PYG{o}{=} \PYG{n+nx}{target}\PYG{p}{.}\PYG{n+nx}{attr}\PYG{p}{(}\PYG{l+s+s2}{"op"}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"clicked - the operation is "} \PYG{o}{+} \PYG{n+nx}{aid} \PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Now we will create the function which is called from the previous \code{beforepageshow.js} by, creating an additional folder inside \code{evently} named \code{tagListContent}.
Now, the function \code{\_init} is defined by creating a folder named \code{\_init} inside the \code{tagListContent} folder. Here we will add the files we know from before:
\begin{itemize}
\item {} 
\textbf{mustache.html}: This is the actual design of one entry in the tag list (the list that groups notes by their tags)
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\textless{}ul} \PYG{n+na}{id=}\PYG{l+s}{"taglist"} \PYG{n+na}{data-role=}\PYG{l+s}{"listview"}\PYG{n+nt}{\textgreater{}}
\PYGZob{}\PYGZob{}\PYGZsh{}rows\PYGZcb{}\PYGZcb{}
    \PYG{n+nt}{\textless{}li}\PYG{n+nt}{\textgreater{}}
        \PYG{n+nt}{\textless{}a} \PYG{n+na}{href=}\PYG{l+s}{"\PYGZsh{}titleListPage"} \PYG{n+na}{id=}\PYG{l+s}{\PYGZob{}\PYGZob{}key\PYGZcb{}\PYGZcb{}}\PYG{n+nt}{\textgreater{}}\PYGZob{}\PYGZob{}key\PYGZcb{}\PYGZcb{} occurs \PYGZob{}\PYGZob{}value\PYGZcb{}\PYGZcb{} times\PYG{n+nt}{\textless{}/a\textgreater{}}
    \PYG{n+nt}{\textless{}/li\textgreater{}}
\PYGZob{}\PYGZob{}/rows\PYGZcb{}\PYGZcb{}
\PYG{n+nt}{\textless{}/ul\textgreater{}}
\end{Verbatim}
\end{quote}

\end{itemize}

Take a look at \code{\{\{key\}\}} and \code{\{\{value\}\}} - later, these occurences will be replaced by the corresponding values from a CouchDB query which itself returns key - value pairs.
\begin{itemize}
\item {} 
\textbf{data.js}:
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{p}{(}\PYG{n+nx}{data}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"evently/tagListContent/\PYGZus{}init/data.js"} \PYG{p}{)}
    \PYG{k+kd}{var} \PYG{n+nx}{thetags} \PYG{o}{=} \PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{rows}\PYG{p}{.}\PYG{n+nx}{map}\PYG{p}{(}\PYG{k+kd}{function}\PYG{p}{(}\PYG{n+nx}{x}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}\PYG{k+kd}{var} \PYG{n+nx}{t}\PYG{o}{=}\PYG{n+nx}{x}\PYG{p}{.}\PYG{n+nx}{key}\PYG{p}{;}
        \PYG{k}{return} \PYG{n+nx}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"body"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{tagsUsed} \PYG{o}{=} \PYG{n+nx}{thetags}\PYG{p}{;}
    \PYG{c+c1}{// store them for later use in input gui}
    \PYG{k}{return} \PYG{n+nx}{data}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
\end{quote}

\item {} 
\textbf{query.json}: Here the view that will be used to query data from our CouchDB is defined.
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
    \PYG{l+s+s2}{"view"} \PYG{o}{:} \PYG{l+s+s2}{"DocbyTag"}\PYG{p}{,}
    \PYG{l+s+s2}{"group"}  \PYG{o}{:} \PYG{k+kc}{true}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
\end{quote}

\end{itemize}

We will have to create the view named \code{DocbyTag} later to be able to use it.
\begin{itemize}
\item {} 
\textbf{after.js}:
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{p}{(}\PYG{n+nx}{data}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"evently/tagListContent/after.js"} \PYG{p}{)}
    \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"\PYGZsh{}taglist"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{listview}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n+nx}{data}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
\end{quote}

\end{itemize}

A \code{selectors} folder should be created: Inside the directory \code{\_init} create a folder called \code{selectors}, then, inside it, another one called \code{a}. Now, as before, create a file named \code{click.js}.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function}\PYG{p}{(}\PYG{n+nx}{event}\PYG{p}{,} \PYG{n+nx}{name}\PYG{p}{,} \PYG{n+nx}{pass}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k+kd}{var} \PYG{n+nx}{target} \PYG{o}{=} \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{n+nx}{event}\PYG{p}{.}\PYG{n+nx}{target}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"evently/tagListContent/\PYGZus{}init/selectors/a/click.js"}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kd}{var} \PYG{n+nx}{tag} \PYG{o}{=} \PYG{n+nx}{target}\PYG{p}{.}\PYG{n+nx}{attr}\PYG{p}{(}\PYG{l+s+s2}{"id"}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"body"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{tagSelected} \PYG{o}{=} \PYG{n+nx}{tag}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Now, we have to define the view for the query to the database. In our example, the view is called \code{DocbyTag}. So, we have to move to the \code{./views} folder and add one with the name \code{DocbyTag}.
Inside this folder, we can create two files representing a CouchDB view: one called \code{map.js} and the other one called \code{reduce.js}.
The code we have to enter to each of them is as follows:
\begin{itemize}
\item {} 
\textbf{map.js}
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function}\PYG{p}{(}\PYG{n+nx}{doc}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n+nx}{doc}\PYG{p}{.}\PYG{n+nx}{TextNote}\PYG{p}{.}\PYG{n+nx}{note}\PYG{p}{.}\PYG{n+nx}{tags}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{k+kd}{var} \PYG{n+nx}{words} \PYG{o}{=} \PYG{n+nx}{doc}\PYG{p}{.}\PYG{n+nx}{TextNote}\PYG{p}{.}\PYG{n+nx}{note}\PYG{p}{.}\PYG{n+nx}{tags}\PYG{p}{;}
                \PYG{k}{for} \PYG{p}{(}\PYG{k+kd}{var} \PYG{n+nx}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n+nx}{i} \PYG{o}{\textless{}} \PYG{p}{(}\PYG{n+nx}{words}\PYG{p}{.}\PYG{n+nx}{length}\PYG{p}{)}\PYG{p}{;} \PYG{n+nx}{i}\PYG{o}{++}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                        \PYG{k+kd}{var} \PYG{n+nx}{value} \PYG{o}{=} \PYG{n+nx}{words}\PYG{p}{[}\PYG{n+nx}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n+nx}{toUpperCase}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                        \PYG{n+nx}{emit}\PYG{p}{(}\PYG{n+nx}{value}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
\end{quote}

\item {} 
\textbf{reduce.js}
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function}\PYG{p}{(}\PYG{n+nx}{key}\PYG{p}{,} \PYG{n+nx}{values}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nx}{sum}\PYG{p}{(}\PYG{n+nx}{values}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
\end{quote}

\end{itemize}

If we export our CouchApp again and open it, we will see one entry:

\includegraphics{4_onetag.png}

This is the summary of all notes in our CouchApp so far. As we have just one note inside our CouchApp, the list shows only one tag with only one occurence.
But if we click on it, nothing happens yet, because we have not coded the part yet to list all notes from a specific tag.


\subsection{List Notes from Tag}
\label{4-Logic:list-notes-from-tag}
\includegraphics{graphviz-a6da2fe1a356cc9c333209297f0cc6a1c1cbcdc1.pdf}

We want the list of notes to be refreshed every time the page is shown. The list itself is located inside \code{index.html} at the DIV with \code{id=titleListContent}.
So, if we move to this evently event and open the file \code{/evently/titleListContent/updateTitleList/async.js} we can see a function call for \code{doView}.
This function does not exist yet. We will have to add it to our already infamous{}`{}`logic.js{}`{}` inside the \code{/\_attachments} folder:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{n+nx}{doView} \PYG{p}{(}\PYG{n+nx}{view}\PYG{p}{,} \PYG{n+nx}{json}\PYG{p}{,} \PYG{n+nx}{callback}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"dbViewWithKey "}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nx}{json}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}db}\PYG{p}{.}\PYG{n+nx}{view}\PYG{p}{(}\PYG{p}{(}\PYG{n+nx}{\PYGZdl{}appname} \PYG{o}{+} \PYG{l+s+s2}{"/"} \PYG{o}{+} \PYG{n+nx}{view}\PYG{p}{)}\PYG{p}{,}
                \PYG{n+nx}{XXmerge} \PYG{p}{(}\PYG{n+nx}{json}\PYG{p}{,} \PYG{p}{\PYGZob{}}
                        \PYG{n+nx}{async} \PYG{o}{:} \PYG{k+kc}{false}\PYG{p}{,}
                        \PYG{n+nx}{success}\PYG{o}{:} \PYG{k+kd}{function} \PYG{p}{(}\PYG{n+nx}{data}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                                \PYG{n+nx}{callback}\PYG{p}{(}\PYG{n+nx}{data}\PYG{p}{)}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}\PYG{p}{,}
                        \PYG{n+nx}{error}\PYG{o}{:} \PYG{k+kd}{function} \PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                                \PYG{n+nx}{alert}\PYG{p}{(}\PYG{l+s+s2}{"Cannot find the document with id "} \PYG{o}{+} \PYG{n+nx}{keyvalue}\PYG{p}{)}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}\PYG{p}{)}
        \PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

This function needs another one, we will define right now, called \code{XXmerge}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{n+nx}{XXmerge}\PYG{p}{(}\PYG{n+nx}{o}\PYG{p}{,} \PYG{n+nx}{ob}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kd}{var} \PYG{n+nx}{z} \PYG{k}{in} \PYG{n+nx}{ob}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{k}{if} \PYG{p}{(}\PYG{n+nx}{ob}\PYG{p}{.}\PYG{n+nx}{hasOwnProperty}\PYG{p}{(}\PYG{n+nx}{z}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                        \PYG{n+nx}{o}\PYG{p}{[}\PYG{n+nx}{z}\PYG{p}{]} \PYG{o}{=} \PYG{n+nx}{ob}\PYG{p}{[}\PYG{n+nx}{z}\PYG{p}{]}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n+nx}{o}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Now we create the view \code{DocbyTag2} which is used to request notes of a specific tag from the CouchDB. Go to the \code{./views} foder and add one with the name \code{DocbyTag2}. Inside this new folder, create a files representing our view:
\begin{itemize}
\item {} 
\textbf{map.js}
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function}\PYG{p}{(}\PYG{n+nx}{doc}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n+nx}{doc}\PYG{p}{.}\PYG{n+nx}{TextNote}\PYG{p}{.}\PYG{n+nx}{note}\PYG{p}{.}\PYG{n+nx}{tags}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k+kd}{var} \PYG{n+nx}{words} \PYG{o}{=} \PYG{n+nx}{doc}\PYG{p}{.}\PYG{n+nx}{TextNote}\PYG{p}{.}\PYG{n+nx}{note}\PYG{p}{.}\PYG{n+nx}{tags}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kd}{var} \PYG{n+nx}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n+nx}{i} \PYG{o}{\textless{}} \PYG{p}{(}\PYG{n+nx}{words}\PYG{p}{.}\PYG{n+nx}{length}\PYG{p}{)}\PYG{p}{;} \PYG{n+nx}{i}\PYG{o}{++}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{k+kd}{var} \PYG{n+nx}{value} \PYG{o}{=} \PYG{n+nx}{words}\PYG{p}{[}\PYG{n+nx}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n+nx}{toUpperCase}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{n+nx}{emit}\PYG{p}{(}\PYG{n+nx}{value}\PYG{p}{,} \PYG{n+nx}{doc}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
\end{quote}

\end{itemize}

We won't need a reduce function here.

To signal the selection of an entry, we will have to add a selector for ``a'' to the \code{updateTitleList} event inside the \code{evently} folder: Create a new folder named \code{selectors} inside the \code{updateTitleList} folder which itself is located inside the \code{titleListContent} directory. In there, go on by creating another one named \code{a}. Inside this directory we will create a file named \code{click.js}. The content of this file should be:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function}\PYG{p}{(}\PYG{n+nx}{event}\PYG{p}{,} \PYG{n+nx}{name}\PYG{p}{,} \PYG{n+nx}{pass}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k+kd}{var} \PYG{n+nx}{target} \PYG{o}{=} \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{n+nx}{event}\PYG{p}{.}\PYG{n+nx}{target}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"selectNote in evently/titleListContent/updateTitleList/selectors/a"}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n+nx}{target}\PYG{p}{.}\PYG{n+nx}{is}\PYG{p}{(}\PYG{l+s+s1}{'a'}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{k+kd}{var} \PYG{n+nx}{idval} \PYG{o}{=} \PYG{n+nx}{target}\PYG{p}{.}\PYG{n+nx}{attr}\PYG{p}{(}\PYG{l+s+s2}{"id"}\PYG{p}{)}\PYG{p}{;}
                \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"body"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{idSelected}\PYG{o}{=}\PYG{n+nx}{idval}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

This will set the \code{idSelected} value stored in the \code{data} element of the \code{body} to the ID of the selected note. This is important later on when we will actually display the content of a note.

This is what you will see, if you click on any tagList item now:

\includegraphics{4_onenote.png}

Now, we will implement the parts that allow us to open and edit an existing note.


\subsection{Open Notes}
\label{4-Logic:open-notes}
\includegraphics{graphviz-b15c5b89d19b8ffaf8c06e9d09bca44a8270df1f.pdf}

To open a note, we need to implement another evently event.
Go to your \code{evently} folder and create a directory named \code{editPage}.

There you have to create the file \code{pagebeforeshow.js}. Its content should read as follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{p}{(}\PYG{n+nx}{data}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"evently/editPage/pagebeforeshow.js"} \PYG{o}{+} \PYG{n+nx}{data}\PYG{p}{)}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nx}{data}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"\PYGZsh{}editContent"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{trigger}\PYG{p}{(}\PYG{l+s+s2}{"shownote"}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n+nx}{data}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

This seems familiar. The function \code{shownote} in the element \code{editContent} is triggered.
But within this \code{shownote} function, another one is called that does not yet exist. It has the name \code{doGetDoc}. We will add it to our \code{./\_attachments/logic.js}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{n+nx}{doGetDoc} \PYG{p}{(}\PYG{n+nx}{docid}\PYG{p}{,} \PYG{n+nx}{callback}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"doGetDoc "} \PYG{o}{+} \PYG{n+nx}{docid}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}db}\PYG{p}{.}\PYG{n+nx}{openDoc} \PYG{p}{(}\PYG{n+nx}{docid}\PYG{p}{,} \PYG{p}{\PYGZob{}}
                \PYG{n+nx}{success}\PYG{o}{:} \PYG{k+kd}{function} \PYG{p}{(}\PYG{n+nx}{data}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                        \PYG{n+nx}{callback}\PYG{p}{(}\PYG{n+nx}{data}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}\PYG{p}{,}
                \PYG{n+nx}{error}\PYG{o}{:} \PYG{k+kd}{function} \PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                        \PYG{n+nx}{alert}\PYG{p}{(}\PYG{l+s+s2}{"Cannot find the document with id "} \PYG{o}{+} \PYG{n+nx}{keyvalue}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Next, we will add a ``\_init'' method by creating a directory called \code{\_init} within the \code{editPage} folder. This function is executed when \emph{editPage} is initialized. Inside \code{\_init} create a \code{selectors} directory.
Here we have to add two elements to be selected, depending on whether we want to delete or save a note. Let's take a look at an excerp of the editPage inside our \code{index.html}:

\begin{Verbatim}[commandchars=@\[\]]
...
@textless[]a op="delete" href="@#titleListPage"  data-role="button" data-theme="b"@textgreater[]DELETE Note@textless[]/a@textgreater[]
...
@textless[]a op="save" href="@#titleListPage"  data-role="button" data-theme="a"@textgreater[]SAVE Note@textless[]/a@textgreater[]
...
\end{Verbatim}

As we can see, there are two \code{a} elements, one with the attribute \code{op="delete"} and the other one with \code{op="save"}. With CouchApp and Evently it is not only possible to attach a function to the \code{a} element, but also distinguish them by their attributes.
So, let's add a function for the delete option. Still within \code{selectors} create a directory named \code{a{[}op=delete{]}}. I guess you have noticed how to include attributes in this notation. Enter our new directory and create a file called \code{click.js}, because we want do define an action to be executed when we click the delete button.
The content of this file should look like this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function}\PYG{p}{(}\PYG{n+nx}{event}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k+kd}{var} \PYG{n+nx}{target} \PYG{o}{=} \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{n+nx}{event}\PYG{p}{.}\PYG{n+nx}{currentTarget}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//probably currentTarget needed because this is a button}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"editPage - shownote - a - delete -click.js "}\PYG{p}{)}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nx}{event}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nx}{target}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kd}{var} \PYG{n+nx}{aid} \PYG{o}{=} \PYG{n+nx}{target}\PYG{p}{.}\PYG{n+nx}{attr}\PYG{p}{(}\PYG{l+s+s2}{"op"}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"clicked - the tag is "} \PYG{o}{+} \PYG{n+nx}{aid} \PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"editContent/\PYGZus{}init/selectors/a[op=delete]/click.js"}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"body"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{data}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kd}{var} \PYG{n+nx}{docvalue}\PYG{o}{=} \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"body"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{docEdited}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nx}{docvalue}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kd}{var} \PYG{n+nx}{docid} \PYG{o}{=} \PYG{n+nx}{docvalue}\PYG{p}{.}\PYG{n+nx}{\PYGZus{}id}\PYG{p}{,}
                \PYG{n+nx}{docrev} \PYG{o}{=}\PYG{n+nx}{docvalue}\PYG{p}{.}\PYG{n+nx}{\PYGZus{}rev}

        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"docid in delete "} \PYG{o}{+} \PYG{n+nx}{docid} \PYG{o}{+} \PYG{l+s+s2}{" rev "} \PYG{o}{+} \PYG{n+nx}{docrev}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kd}{var} \PYG{n+nb}{document} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{"\PYGZus{}id"}\PYG{o}{:} \PYG{n+nx}{docid}\PYG{p}{,} \PYG{l+s+s2}{"\PYGZus{}rev"}\PYG{o}{:} \PYG{n+nx}{docrev}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nb}{document}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{doDeleteDocument} \PYG{p}{(}\PYG{n+nb}{document}\PYG{p}{)}\PYG{p}{;}

        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"editPage after delete"}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nb}{document}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The most important part of this code is the line \code{doDeleteDocument (document);}. This represents a function that should be located inside \code{/\_attachments/logic.js}. So, we will enter it there:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function} \PYG{n+nx}{doDeleteDocument}\PYG{p}{(}\PYG{n+nb}{document}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{\PYGZdl{}db}\PYG{p}{.}\PYG{n+nx}{removeDoc}\PYG{p}{(}\PYG{n+nb}{document}\PYG{p}{,} \PYG{p}{\PYGZob{}}
                \PYG{n+nx}{async} \PYG{o}{:} \PYG{k+kc}{false}\PYG{p}{,}
    \PYG{n+nx}{success}\PYG{o}{:} \PYG{k+kd}{function} \PYG{p}{(}\PYG{n+nx}{data}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"body"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{docEdited} \PYG{o}{=} \PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{id}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"document deleted - success"} \PYG{o}{+} \PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{id} \PYG{o}{+} \PYG{l+s+s2}{" "} \PYG{o}{+}  \PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{rev}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{n+nx}{error}\PYG{o}{:} \PYG{k+kd}{function} \PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{alert}\PYG{p}{(}\PYG{l+s+s2}{"Cannot delete document."}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Next, we will include functionality to edit an existing note. As with the ``delete'' option, we need to create a folder inside \code{./evently/editPage/\_init/selectors}. Only this time, we will name it \code{a{[}op=save{]}}.
Inside this folder, also add a \code{click.js} file and fill it with this code:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{function}\PYG{p}{(}\PYG{n+nx}{event}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k+kd}{var} \PYG{n+nx}{target} \PYG{o}{=} \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{n+nx}{event}\PYG{p}{.}\PYG{n+nx}{currentTarget}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//probably currentTarget needed because this is a button}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"editPage - shownote - a save -click.js "}\PYG{p}{)}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nx}{event}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nx}{target}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kd}{var} \PYG{n+nx}{aid} \PYG{o}{=} \PYG{n+nx}{target}\PYG{p}{.}\PYG{n+nx}{attr}\PYG{p}{(}\PYG{l+s+s2}{"op"}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"clicked - the tag is "} \PYG{o}{+} \PYG{n+nx}{aid} \PYG{p}{)}\PYG{p}{;}

        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"editContent/\PYGZus{}init/selectors/a[op=save]/click.js"}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"body"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{data}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// why is this not availalbe here?}
        \PYG{k+kd}{var} \PYG{n+nx}{docvalue}\PYG{o}{=} \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"body"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{docEdited}\PYG{p}{;} \PYG{c+c1}{//edata.docEdited;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nx}{docvalue}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kd}{var} \PYG{n+nx}{docid} \PYG{o}{=} \PYG{n+nx}{docvalue}\PYG{p}{.}\PYG{n+nx}{\PYGZus{}id}\PYG{p}{,}
                \PYG{n+nx}{docrev} \PYG{o}{=}\PYG{n+nx}{docvalue}\PYG{p}{.}\PYG{n+nx}{\PYGZus{}rev}\PYG{p}{,}
                \PYG{n+nx}{title} \PYG{o}{=} \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s1}{'input[name=title]'}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{val}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                \PYG{n+nx}{text} \PYG{o}{=} \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s1}{'textarea\PYGZsh{}editTextField'}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{val}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                \PYG{n+nx}{tags} \PYG{o}{=} \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s1}{'input[name=tags]'}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{val}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{split}\PYG{p}{(}\PYG{l+s+s2}{" "}\PYG{p}{)}\PYG{p}{;}

        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"body"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{data}\PYG{p}{.}\PYG{n+nx}{tagSelected}\PYG{o}{=}\PYG{n+nx}{tags}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{.}\PYG{n+nx}{toUpperCase}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"docid in save doc "} \PYG{o}{+} \PYG{n+nx}{docid} \PYG{o}{+} \PYG{l+s+s2}{" rev "} \PYG{o}{+} \PYG{n+nx}{docrev} \PYG{o}{+} \PYG{l+s+s2}{" title "} \PYG{o}{+} \PYG{n+nx}{title}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kd}{var} \PYG{n+nb}{document} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{"\PYGZus{}id"}\PYG{o}{:} \PYG{n+nx}{docid}\PYG{p}{,}
                \PYG{l+s+s2}{"\PYGZus{}rev"}\PYG{o}{:} \PYG{n+nx}{docrev}\PYG{p}{,}
                \PYG{l+s+s2}{"type"} \PYG{o}{:} \PYG{l+s+s2}{"note"}\PYG{p}{,}
                \PYG{l+s+s2}{"TextNote"} \PYG{o}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{"note"} \PYG{o}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{"title"}\PYG{o}{:} \PYG{n+nx}{title}\PYG{p}{,} \PYG{l+s+s2}{"text"} \PYG{o}{:} \PYG{n+nx}{text}\PYG{p}{,} \PYG{l+s+s2}{"tags"} \PYG{o}{:} \PYG{n+nx}{tags}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nb}{document}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{doStoreDocument}\PYG{p}{(}\PYG{n+nb}{document}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//braucht alte id und rev}

        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{l+s+s2}{"editPage after store"}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{log}\PYG{p}{(}\PYG{n+nb}{document}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{(}\PYG{l+s+s2}{"\PYGZsh{}editContent"}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{trigger}\PYG{p}{(}\PYG{l+s+s2}{"shownote"}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZdl{}}\PYG{p}{.}\PYG{n+nx}{mobile}\PYG{p}{.}\PYG{n+nx}{changePage}\PYG{p}{(}\PYG{l+s+s2}{"\PYGZsh{}editPage"}\PYG{p}{,} \PYG{l+s+s2}{"slidedown"}\PYG{p}{,} \PYG{k+kc}{true}\PYG{p}{,} \PYG{k+kc}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

With this we have completed the core of our CouchApp. We can create new notes which will be displayed, grouped by their assigned tags and edit them. All of this happens inside the CouchDB and your browser.

As usual, you should export the CouchApp directory tree to your CouchDB with the command \code{enotes\$ couchapp push enotes}. After that, access your CouchApp in your web browser at \href{http://127.0.0.1:5984/enotes/\_design/enotes/index.html}{http://127.0.0.1:5984/enotes/\_design/enotes/index.html}.



\renewcommand{\indexname}{Index}
\printindex
\end{document}
